{
  "processStartDateTime" : "2021-03-06T15:39:59.992",
  "processDurationSeconds" : 3363,
  "programSources" : [
    {
      "id" : 1,
      "source" : "target/transmut-20210306153959/mutated-src/example/AggregationQuery.scala",
      "sourceName" : "AggregationQuery",
      "programs" : [
        {
          "id" : 1,
          "programSourceId" : 1,
          "name" : "aggregation",
          "code" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "datasets" : [
            {
              "id" : 1,
              "name" : "input",
              "datasetType" : "RDD[String]",
              "inputDataset" : true,
              "outputDataset" : false
            },
            {
              "id" : 2,
              "name" : "userVisits",
              "datasetType" : "RDD[UserVisit]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 3,
              "name" : "userVisitsTuples",
              "datasetType" : "RDD[(String, Float)]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 4,
              "name" : "results",
              "datasetType" : "RDD[(String, Float)]",
              "inputDataset" : false,
              "outputDataset" : true
            }
          ],
          "transformations" : [
            {
              "id" : 1,
              "name" : "map",
              "inputTypes" : [
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[UserVisit]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 2,
              "name" : "map",
              "inputTypes" : [
                "RDD[UserVisit]"
              ],
              "outputTypes" : [
                "RDD[(String, Float)]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 3,
              "name" : "reduceByKey",
              "inputTypes" : [
                "RDD[(String, Float)]"
              ],
              "outputTypes" : [
                "RDD[(String, Float)]"
              ],
              "loadTransformation" : false
            }
          ],
          "edges" : [
            {
              "id" : 1,
              "datasetId" : 1,
              "transformationId" : 1,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 2,
              "datasetId" : 2,
              "transformationId" : 1,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 3,
              "datasetId" : 2,
              "transformationId" : 2,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 4,
              "datasetId" : 3,
              "transformationId" : 2,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 5,
              "datasetId" : 3,
              "transformationId" : 3,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 6,
              "datasetId" : 4,
              "transformationId" : 3,
              "direction" : "TransformationToDataset"
            }
          ],
          "mutants" : [
            {
              "id" : 1,
              "originalProgramId" : 1,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples\n  results\n}",
              "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 2,
              "originalProgramId" : 1,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map { (inputParameter: String) => {\n    val originalFunction = parseUserVisits(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[UserVisit]\n  } }\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
              "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 3,
              "originalProgramId" : 1,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
              "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 4,
              "originalProgramId" : 1,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 0f)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
              "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 5,
              "originalProgramId" : 1,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 1f)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
              "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 6,
              "originalProgramId" : 1,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Float.MaxValue)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
              "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 7,
              "originalProgramId" : 1,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Float.MinValue)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
              "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 8,
              "originalProgramId" : 1,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, -originalValue._2)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
              "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 9,
              "originalProgramId" : 1,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits).distinct()\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
              "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 10,
              "originalProgramId" : 1,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple).distinct()\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
              "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 11,
              "originalProgramId" : 1,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }.distinct()\n  results\n}",
              "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 12,
              "originalProgramId" : 1,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => firstParameter }\n  results\n}",
              "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 13,
              "originalProgramId" : 1,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => secondParameter }\n  results\n}",
              "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 14,
              "originalProgramId" : 1,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => {\n    val originalFunction = ((x: Float, y: Float) => x + y)(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  results\n}",
              "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 15,
              "originalProgramId" : 1,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => {\n    val originalFunction = ((x: Float, y: Float) => x + y)(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  results\n}",
              "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 16,
              "originalProgramId" : 1,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => {\n    val originalFunction = ((x: Float, y: Float) => x + y)(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  results\n}",
              "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
              "status" : "Equivalent"
            }
          ],
          "removedMutants" : [
          ],
          "mutationOperatorsMetrics" : {
            "totalMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 7,
              "UTD" : 1,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 5,
              "OTI" : 0,
              "DTI" : 3,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalKilledMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 7,
              "UTD" : 1,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 4,
              "OTI" : 0,
              "DTI" : 2,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalLivedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalEquivalentMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 1,
              "OTI" : 0,
              "DTI" : 1,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalErrorMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalRemovedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "descriptionPerOperator" : {
              "FTD" : "Filter Transformation Deletion",
              "JTR" : "Join Transformation Replacement",
              "UTR" : "Unary Transformation Replacement",
              "MTR" : "Mapping Transformation Replacement",
              "UTD" : "Unary Transformation Deletion",
              "OTD" : "Order Transformation Deletion",
              "BTR" : "Binary Transformation Replacement",
              "STR" : "Set Transformation Replacement",
              "BTS" : "Binary Transformation Swap",
              "ATR" : "Aggregation Transformation Replacement",
              "OTI" : "Order Transformation Inversion",
              "DTI" : "Distinct Transformation Insertion",
              "DTD" : "Distinct Transformation Deletion",
              "NFTP" : "Negation of Filter Transformation Predicate",
              "UTS" : "Unary Transformation Swap"
            }
          },
          "totalDatasets" : 4,
          "totalTransformations" : 3,
          "totalMutants" : 16,
          "totalKilledMutants" : 14,
          "totalLivedMutants" : 0,
          "totalEquivalentMutants" : 2,
          "totalErrorMutants" : 0,
          "totalRemovedMutants" : 0,
          "mutationScore" : 1.0
        }
      ],
      "mutants" : [
        {
          "id" : 1,
          "originalProgramId" : 1,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 2,
          "originalProgramId" : 1,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map { (inputParameter: String) => {\n    val originalFunction = parseUserVisits(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[UserVisit]\n  } }\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 3,
          "originalProgramId" : 1,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 4,
          "originalProgramId" : 1,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 0f)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 5,
          "originalProgramId" : 1,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 1f)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 6,
          "originalProgramId" : 1,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Float.MaxValue)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 7,
          "originalProgramId" : 1,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Float.MinValue)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 8,
          "originalProgramId" : 1,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, -originalValue._2)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 9,
          "originalProgramId" : 1,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits).distinct()\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 10,
          "originalProgramId" : 1,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple).distinct()\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 11,
          "originalProgramId" : 1,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }.distinct()\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 12,
          "originalProgramId" : 1,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => firstParameter }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 13,
          "originalProgramId" : 1,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => secondParameter }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 14,
          "originalProgramId" : 1,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => {\n    val originalFunction = ((x: Float, y: Float) => x + y)(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 15,
          "originalProgramId" : 1,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => {\n    val originalFunction = ((x: Float, y: Float) => x + y)(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 16,
          "originalProgramId" : 1,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => {\n    val originalFunction = ((x: Float, y: Float) => x + y)(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Equivalent"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 7,
          "UTD" : 1,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 5,
          "OTI" : 0,
          "DTI" : 3,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 7,
          "UTD" : 1,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 4,
          "OTI" : 0,
          "DTI" : 2,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 1,
          "OTI" : 0,
          "DTI" : 1,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalPrograms" : 1,
      "totalDatasets" : 4,
      "totalTransformations" : 3,
      "totalMutants" : 16,
      "totalKilledMutants" : 14,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 2,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 2,
      "source" : "target/transmut-20210306153959/mutated-src/example/DistinctUserVisitsPerPage.scala",
      "sourceName" : "DistinctUserVisitsPerPage",
      "programs" : [
        {
          "id" : 2,
          "programSourceId" : 2,
          "name" : "distinctUserVisitsPerPage",
          "code" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "datasets" : [
            {
              "id" : 5,
              "name" : "input",
              "datasetType" : "RDD[String]",
              "inputDataset" : true,
              "outputDataset" : false
            },
            {
              "id" : 6,
              "name" : "userVisits",
              "datasetType" : "RDD[UserVisit]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 7,
              "name" : "userAccesses",
              "datasetType" : "RDD[(String, String)]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 8,
              "name" : "mapedUserAccess",
              "datasetType" : "RDD[(String, Set[String])]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 9,
              "name" : "distinctSites",
              "datasetType" : "RDD[(String, Set[String])]",
              "inputDataset" : false,
              "outputDataset" : true
            }
          ],
          "transformations" : [
            {
              "id" : 4,
              "name" : "map",
              "inputTypes" : [
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[UserVisit]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 5,
              "name" : "map",
              "inputTypes" : [
                "RDD[UserVisit]"
              ],
              "outputTypes" : [
                "RDD[(String, String)]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 6,
              "name" : "map",
              "inputTypes" : [
                "RDD[(String, String)]"
              ],
              "outputTypes" : [
                "RDD[(String, Set[String])]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 7,
              "name" : "reduceByKey",
              "inputTypes" : [
                "RDD[(String, Set[String])]"
              ],
              "outputTypes" : [
                "RDD[(String, Set[String])]"
              ],
              "loadTransformation" : false
            }
          ],
          "edges" : [
            {
              "id" : 7,
              "datasetId" : 5,
              "transformationId" : 4,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 8,
              "datasetId" : 6,
              "transformationId" : 4,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 9,
              "datasetId" : 6,
              "transformationId" : 5,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 10,
              "datasetId" : 7,
              "transformationId" : 5,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 11,
              "datasetId" : 7,
              "transformationId" : 6,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 12,
              "datasetId" : 8,
              "transformationId" : 6,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 13,
              "datasetId" : 8,
              "transformationId" : 7,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 14,
              "datasetId" : 9,
              "transformationId" : 7,
              "direction" : "TransformationToDataset"
            }
          ],
          "mutants" : [
            {
              "id" : 17,
              "originalProgramId" : 2,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Killed"
            },
            {
              "id" : 18,
              "originalProgramId" : 2,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map { (inputParameter: String) => {\n    val originalFunction = parseUserVisits(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[UserVisit]\n  } }\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Killed"
            },
            {
              "id" : 19,
              "originalProgramId" : 2,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Killed"
            },
            {
              "id" : 20,
              "originalProgramId" : 2,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, \"\")\n  } }\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Killed"
            },
            {
              "id" : 21,
              "originalProgramId" : 2,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map { (inputParameter: (String, String)) => {\n    val originalFunction = mapSourceIPToSet(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Killed"
            },
            {
              "id" : 22,
              "originalProgramId" : 2,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map { (inputParameter: (String, String)) => {\n    val originalFunction = mapSourceIPToSet(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Set[String](originalValue._2.head))\n  } }\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 23,
              "originalProgramId" : 2,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map { (inputParameter: (String, String)) => {\n    val originalFunction = mapSourceIPToSet(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, originalValue._2.tail)\n  } }\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Killed"
            },
            {
              "id" : 24,
              "originalProgramId" : 2,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map { (inputParameter: (String, String)) => {\n    val originalFunction = mapSourceIPToSet(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Set[String]())\n  } }\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Killed"
            },
            {
              "id" : 25,
              "originalProgramId" : 2,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits).distinct()\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 26,
              "originalProgramId" : 2,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple).distinct()\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 27,
              "originalProgramId" : 2,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet).distinct()\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 28,
              "originalProgramId" : 2,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion).distinct()\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 29,
              "originalProgramId" : 2,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => firstParameter }\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Killed"
            },
            {
              "id" : 30,
              "originalProgramId" : 2,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => secondParameter }\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Killed"
            },
            {
              "id" : 31,
              "originalProgramId" : 2,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => {\n    val originalFunction = setUnion(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Killed"
            },
            {
              "id" : 32,
              "originalProgramId" : 2,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => {\n    val originalFunction = setUnion(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Killed"
            },
            {
              "id" : 33,
              "originalProgramId" : 2,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => {\n    val originalFunction = setUnion(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  distinctSites\n}",
              "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
              "status" : "Equivalent"
            }
          ],
          "removedMutants" : [
          ],
          "mutationOperatorsMetrics" : {
            "totalMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 7,
              "UTD" : 1,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 5,
              "OTI" : 0,
              "DTI" : 4,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalKilledMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 6,
              "UTD" : 1,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 4,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalLivedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalEquivalentMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 1,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 1,
              "OTI" : 0,
              "DTI" : 4,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalErrorMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalRemovedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "descriptionPerOperator" : {
              "FTD" : "Filter Transformation Deletion",
              "JTR" : "Join Transformation Replacement",
              "UTR" : "Unary Transformation Replacement",
              "MTR" : "Mapping Transformation Replacement",
              "UTD" : "Unary Transformation Deletion",
              "OTD" : "Order Transformation Deletion",
              "BTR" : "Binary Transformation Replacement",
              "STR" : "Set Transformation Replacement",
              "BTS" : "Binary Transformation Swap",
              "ATR" : "Aggregation Transformation Replacement",
              "OTI" : "Order Transformation Inversion",
              "DTI" : "Distinct Transformation Insertion",
              "DTD" : "Distinct Transformation Deletion",
              "NFTP" : "Negation of Filter Transformation Predicate",
              "UTS" : "Unary Transformation Swap"
            }
          },
          "totalDatasets" : 5,
          "totalTransformations" : 4,
          "totalMutants" : 17,
          "totalKilledMutants" : 11,
          "totalLivedMutants" : 0,
          "totalEquivalentMutants" : 6,
          "totalErrorMutants" : 0,
          "totalRemovedMutants" : 0,
          "mutationScore" : 1.0
        }
      ],
      "mutants" : [
        {
          "id" : 17,
          "originalProgramId" : 2,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 18,
          "originalProgramId" : 2,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map { (inputParameter: String) => {\n    val originalFunction = parseUserVisits(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[UserVisit]\n  } }\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 19,
          "originalProgramId" : 2,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 20,
          "originalProgramId" : 2,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, \"\")\n  } }\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 21,
          "originalProgramId" : 2,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map { (inputParameter: (String, String)) => {\n    val originalFunction = mapSourceIPToSet(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 22,
          "originalProgramId" : 2,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map { (inputParameter: (String, String)) => {\n    val originalFunction = mapSourceIPToSet(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Set[String](originalValue._2.head))\n  } }\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 23,
          "originalProgramId" : 2,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map { (inputParameter: (String, String)) => {\n    val originalFunction = mapSourceIPToSet(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, originalValue._2.tail)\n  } }\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 24,
          "originalProgramId" : 2,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map { (inputParameter: (String, String)) => {\n    val originalFunction = mapSourceIPToSet(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Set[String]())\n  } }\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 25,
          "originalProgramId" : 2,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits).distinct()\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 26,
          "originalProgramId" : 2,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple).distinct()\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 27,
          "originalProgramId" : 2,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet).distinct()\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 28,
          "originalProgramId" : 2,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion).distinct()\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 29,
          "originalProgramId" : 2,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => firstParameter }\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 30,
          "originalProgramId" : 2,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => secondParameter }\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 31,
          "originalProgramId" : 2,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => {\n    val originalFunction = setUnion(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 32,
          "originalProgramId" : 2,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => {\n    val originalFunction = setUnion(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 33,
          "originalProgramId" : 2,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => {\n    val originalFunction = setUnion(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Equivalent"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 7,
          "UTD" : 1,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 5,
          "OTI" : 0,
          "DTI" : 4,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 6,
          "UTD" : 1,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 4,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 1,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 1,
          "OTI" : 0,
          "DTI" : 4,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalPrograms" : 1,
      "totalDatasets" : 5,
      "totalTransformations" : 4,
      "totalMutants" : 17,
      "totalKilledMutants" : 11,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 6,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 3,
      "source" : "target/transmut-20210306153959/mutated-src/example/JoinQuery.scala",
      "sourceName" : "JoinQuery",
      "programs" : [
        {
          "id" : 3,
          "programSourceId" : 3,
          "name" : "join",
          "code" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "datasets" : [
            {
              "id" : 10,
              "name" : "rankingsLines",
              "datasetType" : "RDD[String]",
              "inputDataset" : true,
              "outputDataset" : false
            },
            {
              "id" : 11,
              "name" : "userVisitsLines",
              "datasetType" : "RDD[String]",
              "inputDataset" : true,
              "outputDataset" : false
            },
            {
              "id" : 12,
              "name" : "rankings",
              "datasetType" : "RDD[Ranking]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 13,
              "name" : "userVisits",
              "datasetType" : "RDD[UserVisit]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 14,
              "name" : "filteredUV",
              "datasetType" : "RDD[UserVisit]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 15,
              "name" : "subqueryUV",
              "datasetType" : "RDD[(String, UserVisit)]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 16,
              "name" : "subqueryR",
              "datasetType" : "RDD[(String, Ranking)]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 17,
              "name" : "subqueryJoin",
              "datasetType" : "RDD[(String, (Ranking, UserVisit))]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 18,
              "name" : "subqueryJoinValues",
              "datasetType" : "RDD[(Ranking, UserVisit)]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 19,
              "name" : "subquerySelect",
              "datasetType" : "RDD[(String, (Float, Int))]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 20,
              "name" : "subqueryGroup",
              "datasetType" : "RDD[(String, Iterable[(Float, Int)])]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 21,
              "name" : "subqueryAggregation",
              "datasetType" : "RDD[Tuple3[String, Float, Int]]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 22,
              "name" : "results",
              "datasetType" : "RDD[Tuple3[String, Float, Int]]",
              "inputDataset" : false,
              "outputDataset" : true
            }
          ],
          "transformations" : [
            {
              "id" : 8,
              "name" : "map",
              "inputTypes" : [
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[Ranking]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 9,
              "name" : "map",
              "inputTypes" : [
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[UserVisit]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 10,
              "name" : "filter",
              "inputTypes" : [
                "RDD[UserVisit]"
              ],
              "outputTypes" : [
                "RDD[UserVisit]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 11,
              "name" : "map",
              "inputTypes" : [
                "RDD[UserVisit]"
              ],
              "outputTypes" : [
                "RDD[(String, UserVisit)]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 12,
              "name" : "map",
              "inputTypes" : [
                "RDD[Ranking]"
              ],
              "outputTypes" : [
                "RDD[(String, Ranking)]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 13,
              "name" : "join",
              "inputTypes" : [
                "RDD[(String, Ranking)]",
                "RDD[(String, UserVisit)]"
              ],
              "outputTypes" : [
                "RDD[(String, (Ranking, UserVisit))]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 14,
              "name" : "values",
              "inputTypes" : [
                "RDD[(String, (Ranking, UserVisit))]"
              ],
              "outputTypes" : [
                "RDD[(Ranking, UserVisit)]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 15,
              "name" : "map",
              "inputTypes" : [
                "RDD[(Ranking, UserVisit)]"
              ],
              "outputTypes" : [
                "RDD[(String, (Float, Int))]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 16,
              "name" : "groupByKey",
              "inputTypes" : [
                "RDD[(String, (Float, Int))]"
              ],
              "outputTypes" : [
                "RDD[(String, Iterable[(Float, Int)])]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 17,
              "name" : "map",
              "inputTypes" : [
                "RDD[(String, Iterable[(Float, Int)])]"
              ],
              "outputTypes" : [
                "RDD[Tuple3[String, Float, Int]]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 18,
              "name" : "sortBy",
              "inputTypes" : [
                "RDD[Tuple3[String, Float, Int]]"
              ],
              "outputTypes" : [
                "RDD[Tuple3[String, Float, Int]]"
              ],
              "loadTransformation" : false
            }
          ],
          "edges" : [
            {
              "id" : 15,
              "datasetId" : 10,
              "transformationId" : 8,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 16,
              "datasetId" : 12,
              "transformationId" : 8,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 17,
              "datasetId" : 11,
              "transformationId" : 9,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 18,
              "datasetId" : 13,
              "transformationId" : 9,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 19,
              "datasetId" : 13,
              "transformationId" : 10,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 20,
              "datasetId" : 14,
              "transformationId" : 10,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 21,
              "datasetId" : 14,
              "transformationId" : 11,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 22,
              "datasetId" : 15,
              "transformationId" : 11,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 23,
              "datasetId" : 12,
              "transformationId" : 12,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 24,
              "datasetId" : 16,
              "transformationId" : 12,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 25,
              "datasetId" : 16,
              "transformationId" : 13,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 26,
              "datasetId" : 15,
              "transformationId" : 13,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 27,
              "datasetId" : 17,
              "transformationId" : 13,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 28,
              "datasetId" : 17,
              "transformationId" : 14,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 29,
              "datasetId" : 18,
              "transformationId" : 14,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 30,
              "datasetId" : 18,
              "transformationId" : 15,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 31,
              "datasetId" : 19,
              "transformationId" : 15,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 32,
              "datasetId" : 19,
              "transformationId" : 16,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 33,
              "datasetId" : 20,
              "transformationId" : 16,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 34,
              "datasetId" : 20,
              "transformationId" : 17,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 35,
              "datasetId" : 21,
              "transformationId" : 17,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 36,
              "datasetId" : 21,
              "transformationId" : 18,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 37,
              "datasetId" : 22,
              "transformationId" : 18,
              "direction" : "TransformationToDataset"
            }
          ],
          "mutants" : [
            {
              "id" : 34,
              "originalProgramId" : 3,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 35,
              "originalProgramId" : 3,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 36,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map { (inputParameter: String) => {\n    val originalFunction = parseRankings(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[Ranking]\n  } }\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 37,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map { (inputParameter: String) => {\n    val originalFunction = parseUserVisits(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[UserVisit]\n  } }\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 38,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 39,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, null.asInstanceOf[UserVisit])\n  } }\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 40,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 41,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, null.asInstanceOf[Ranking])\n  } }\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 42,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 43,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (0f, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 44,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (1f, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 45,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (Float.MaxValue, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 46,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (Float.MinValue, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 47,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (-originalValue._2._1, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 48,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, 0))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 49,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, 1))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 50,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, Int.MaxValue))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 51,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, Int.MinValue))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 52,
              "originalProgramId" : 3,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, -originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 53,
              "originalProgramId" : 3,
              "mutationOperator" : "FTD",
              "mutationOperatorDescription" : "Filter Transformation Deletion",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 54,
              "originalProgramId" : 3,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings).distinct()\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 55,
              "originalProgramId" : 3,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits).distinct()\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 56,
              "originalProgramId" : 3,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange).distinct()\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 57,
              "originalProgramId" : 3,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple).distinct()\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 58,
              "originalProgramId" : 3,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple).distinct()\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 59,
              "originalProgramId" : 3,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV).distinct()\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 60,
              "originalProgramId" : 3,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values.distinct()\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 61,
              "originalProgramId" : 3,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple).distinct()\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 62,
              "originalProgramId" : 3,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey().distinct()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 63,
              "originalProgramId" : 3,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation).distinct()\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 64,
              "originalProgramId" : 3,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false).distinct()\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 65,
              "originalProgramId" : 3,
              "mutationOperator" : "JTR",
              "mutationOperatorDescription" : "Join Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.leftOuterJoin(subqueryUV).map(tuple => (tuple._1, (tuple._2._1, tuple._2._2.getOrElse(null.asInstanceOf[UserVisit]))))\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 66,
              "originalProgramId" : 3,
              "mutationOperator" : "JTR",
              "mutationOperatorDescription" : "Join Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.rightOuterJoin(subqueryUV).map(tuple => (tuple._1, (tuple._2._1.getOrElse(null.asInstanceOf[Ranking]), tuple._2._2)))\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 67,
              "originalProgramId" : 3,
              "mutationOperator" : "JTR",
              "mutationOperatorDescription" : "Join Transformation Replacement",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.fullOuterJoin(subqueryUV).map(tuple => (tuple._1, (tuple._2._1.getOrElse(null.asInstanceOf[Ranking]), tuple._2._2.getOrElse(null.asInstanceOf[UserVisit]))))\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 68,
              "originalProgramId" : 3,
              "mutationOperator" : "OTD",
              "mutationOperatorDescription" : "Order Transformation Deletion",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 69,
              "originalProgramId" : 3,
              "mutationOperator" : "NFTP",
              "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter { (inputParameter: UserVisit) => {\n    val originalFunction = filterUserVisitsDateRange(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 70,
              "originalProgramId" : 3,
              "mutationOperator" : "OTI",
              "mutationOperatorDescription" : "Order Transformation Inversion",
              "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, true)\n  results\n}",
              "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
              "status" : "Killed"
            }
          ],
          "removedMutants" : [
          ],
          "mutationOperatorsMetrics" : {
            "totalMutantsPerOperator" : {
              "FTD" : 1,
              "JTR" : 3,
              "UTR" : 0,
              "MTR" : 17,
              "UTD" : 2,
              "OTD" : 1,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 1,
              "DTI" : 11,
              "DTD" : 0,
              "NFTP" : 1,
              "UTS" : 0
            },
            "totalKilledMutantsPerOperator" : {
              "FTD" : 1,
              "JTR" : 3,
              "UTR" : 0,
              "MTR" : 17,
              "UTD" : 2,
              "OTD" : 1,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 1,
              "DTI" : 9,
              "DTD" : 0,
              "NFTP" : 1,
              "UTS" : 0
            },
            "totalLivedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalEquivalentMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 2,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalErrorMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalRemovedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "descriptionPerOperator" : {
              "FTD" : "Filter Transformation Deletion",
              "JTR" : "Join Transformation Replacement",
              "UTR" : "Unary Transformation Replacement",
              "MTR" : "Mapping Transformation Replacement",
              "UTD" : "Unary Transformation Deletion",
              "OTD" : "Order Transformation Deletion",
              "BTR" : "Binary Transformation Replacement",
              "STR" : "Set Transformation Replacement",
              "BTS" : "Binary Transformation Swap",
              "ATR" : "Aggregation Transformation Replacement",
              "OTI" : "Order Transformation Inversion",
              "DTI" : "Distinct Transformation Insertion",
              "DTD" : "Distinct Transformation Deletion",
              "NFTP" : "Negation of Filter Transformation Predicate",
              "UTS" : "Unary Transformation Swap"
            }
          },
          "totalDatasets" : 13,
          "totalTransformations" : 11,
          "totalMutants" : 37,
          "totalKilledMutants" : 35,
          "totalLivedMutants" : 0,
          "totalEquivalentMutants" : 2,
          "totalErrorMutants" : 0,
          "totalRemovedMutants" : 0,
          "mutationScore" : 1.0
        }
      ],
      "mutants" : [
        {
          "id" : 34,
          "originalProgramId" : 3,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 35,
          "originalProgramId" : 3,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 36,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map { (inputParameter: String) => {\n    val originalFunction = parseRankings(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[Ranking]\n  } }\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 37,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map { (inputParameter: String) => {\n    val originalFunction = parseUserVisits(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[UserVisit]\n  } }\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 38,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 39,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, null.asInstanceOf[UserVisit])\n  } }\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 40,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 41,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, null.asInstanceOf[Ranking])\n  } }\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 42,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 43,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (0f, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 44,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (1f, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 45,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (Float.MaxValue, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 46,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (Float.MinValue, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 47,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (-originalValue._2._1, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 48,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, 0))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 49,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, 1))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 50,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, Int.MaxValue))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 51,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, Int.MinValue))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 52,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, -originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 53,
          "originalProgramId" : 3,
          "mutationOperator" : "FTD",
          "mutationOperatorDescription" : "Filter Transformation Deletion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 54,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings).distinct()\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 55,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits).distinct()\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 56,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange).distinct()\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 57,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple).distinct()\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 58,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple).distinct()\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 59,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV).distinct()\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 60,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values.distinct()\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 61,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple).distinct()\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 62,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey().distinct()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 63,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation).distinct()\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 64,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false).distinct()\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 65,
          "originalProgramId" : 3,
          "mutationOperator" : "JTR",
          "mutationOperatorDescription" : "Join Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.leftOuterJoin(subqueryUV).map(tuple => (tuple._1, (tuple._2._1, tuple._2._2.getOrElse(null.asInstanceOf[UserVisit]))))\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 66,
          "originalProgramId" : 3,
          "mutationOperator" : "JTR",
          "mutationOperatorDescription" : "Join Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.rightOuterJoin(subqueryUV).map(tuple => (tuple._1, (tuple._2._1.getOrElse(null.asInstanceOf[Ranking]), tuple._2._2)))\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 67,
          "originalProgramId" : 3,
          "mutationOperator" : "JTR",
          "mutationOperatorDescription" : "Join Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.fullOuterJoin(subqueryUV).map(tuple => (tuple._1, (tuple._2._1.getOrElse(null.asInstanceOf[Ranking]), tuple._2._2.getOrElse(null.asInstanceOf[UserVisit]))))\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 68,
          "originalProgramId" : 3,
          "mutationOperator" : "OTD",
          "mutationOperatorDescription" : "Order Transformation Deletion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 69,
          "originalProgramId" : 3,
          "mutationOperator" : "NFTP",
          "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter { (inputParameter: UserVisit) => {\n    val originalFunction = filterUserVisitsDateRange(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 70,
          "originalProgramId" : 3,
          "mutationOperator" : "OTI",
          "mutationOperatorDescription" : "Order Transformation Inversion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, true)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 3,
          "UTR" : 0,
          "MTR" : 17,
          "UTD" : 2,
          "OTD" : 1,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 1,
          "DTI" : 11,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 3,
          "UTR" : 0,
          "MTR" : 17,
          "UTD" : 2,
          "OTD" : 1,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 1,
          "DTI" : 9,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 2,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalPrograms" : 1,
      "totalDatasets" : 13,
      "totalTransformations" : 11,
      "totalMutants" : 37,
      "totalKilledMutants" : 35,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 2,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 4,
      "source" : "target/transmut-20210306153959/mutated-src/example/MoviesRatingsAverage.scala",
      "sourceName" : "MoviesRatingsAverage",
      "programs" : [
        {
          "id" : 4,
          "programSourceId" : 4,
          "name" : "moviesRatingsAverage",
          "code" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "datasets" : [
            {
              "id" : 23,
              "name" : "inputRDD",
              "datasetType" : "RDD[String]",
              "inputDataset" : true,
              "outputDataset" : false
            },
            {
              "id" : 24,
              "name" : "ratings",
              "datasetType" : "RDD[(Int, (Double, Double))]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 25,
              "name" : "ratingsSum",
              "datasetType" : "RDD[(Int, (Double, Double))]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 26,
              "name" : "ratingsAverage",
              "datasetType" : "RDD[(Int, Double)]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 27,
              "name" : "ratingsAverageSorted",
              "datasetType" : "RDD[(Int, Double)]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 28,
              "name" : "resultsCVS",
              "datasetType" : "RDD[String]",
              "inputDataset" : false,
              "outputDataset" : true
            }
          ],
          "transformations" : [
            {
              "id" : 19,
              "name" : "flatMap",
              "inputTypes" : [
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[(Int, (Double, Double))]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 20,
              "name" : "reduceByKey",
              "inputTypes" : [
                "RDD[(Int, (Double, Double))]"
              ],
              "outputTypes" : [
                "RDD[(Int, (Double, Double))]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 21,
              "name" : "mapValues",
              "inputTypes" : [
                "RDD[(Int, (Double, Double))]"
              ],
              "outputTypes" : [
                "RDD[(Int, Double)]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 22,
              "name" : "sortByKey",
              "inputTypes" : [
                "RDD[(Int, Double)]"
              ],
              "outputTypes" : [
                "RDD[(Int, Double)]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 23,
              "name" : "map",
              "inputTypes" : [
                "RDD[(Int, Double)]"
              ],
              "outputTypes" : [
                "RDD[String]"
              ],
              "loadTransformation" : false
            }
          ],
          "edges" : [
            {
              "id" : 38,
              "datasetId" : 23,
              "transformationId" : 19,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 39,
              "datasetId" : 24,
              "transformationId" : 19,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 40,
              "datasetId" : 24,
              "transformationId" : 20,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 41,
              "datasetId" : 25,
              "transformationId" : 20,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 42,
              "datasetId" : 25,
              "transformationId" : 21,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 43,
              "datasetId" : 26,
              "transformationId" : 21,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 44,
              "datasetId" : 26,
              "transformationId" : 22,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 45,
              "datasetId" : 27,
              "transformationId" : 22,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 46,
              "datasetId" : 27,
              "transformationId" : 23,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 47,
              "datasetId" : 28,
              "transformationId" : 23,
              "direction" : "TransformationToDataset"
            }
          ],
          "mutants" : [
            {
              "id" : 71,
              "originalProgramId" : 4,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Killed"
            },
            {
              "id" : 72,
              "originalProgramId" : 4,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Killed"
            },
            {
              "id" : 73,
              "originalProgramId" : 4,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 74,
              "originalProgramId" : 4,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Killed"
            },
            {
              "id" : 75,
              "originalProgramId" : 4,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 76,
              "originalProgramId" : 4,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    List[(Int, (Double, Double))]()\n  } }\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Killed"
            },
            {
              "id" : 77,
              "originalProgramId" : 4,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (inputParameter: (Int, Double)) => {\n    val originalFunction = ((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))(_)\n    val originalValue = originalFunction(inputParameter)\n    \"\"\n  } }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Killed"
            },
            {
              "id" : 78,
              "originalProgramId" : 4,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings).distinct()\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Killed"
            },
            {
              "id" : 79,
              "originalProgramId" : 4,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple).distinct()\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 80,
              "originalProgramId" : 4,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide).distinct()\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 81,
              "originalProgramId" : 4,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false).distinct()\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Killed"
            },
            {
              "id" : 82,
              "originalProgramId" : 4,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }.distinct()\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Killed"
            },
            {
              "id" : 83,
              "originalProgramId" : 4,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => firstParameter }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Killed"
            },
            {
              "id" : 84,
              "originalProgramId" : 4,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => secondParameter }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Killed"
            },
            {
              "id" : 85,
              "originalProgramId" : 4,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => {\n    val originalFunction = aggregateDoubleTuple(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Killed"
            },
            {
              "id" : 86,
              "originalProgramId" : 4,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => {\n    val originalFunction = aggregateDoubleTuple(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Killed"
            },
            {
              "id" : 87,
              "originalProgramId" : 4,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => {\n    val originalFunction = aggregateDoubleTuple(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 88,
              "originalProgramId" : 4,
              "mutationOperator" : "OTD",
              "mutationOperatorDescription" : "Order Transformation Deletion",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Killed"
            },
            {
              "id" : 89,
              "originalProgramId" : 4,
              "mutationOperator" : "OTI",
              "mutationOperatorDescription" : "Order Transformation Inversion",
              "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(true)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
              "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
              "status" : "Killed"
            }
          ],
          "removedMutants" : [
          ],
          "mutationOperatorsMetrics" : {
            "totalMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 5,
              "UTD" : 2,
              "OTD" : 1,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 5,
              "OTI" : 1,
              "DTI" : 5,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalKilledMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 3,
              "UTD" : 2,
              "OTD" : 1,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 4,
              "OTI" : 1,
              "DTI" : 3,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalLivedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalEquivalentMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 2,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 1,
              "OTI" : 0,
              "DTI" : 2,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalErrorMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalRemovedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "descriptionPerOperator" : {
              "FTD" : "Filter Transformation Deletion",
              "JTR" : "Join Transformation Replacement",
              "UTR" : "Unary Transformation Replacement",
              "MTR" : "Mapping Transformation Replacement",
              "UTD" : "Unary Transformation Deletion",
              "OTD" : "Order Transformation Deletion",
              "BTR" : "Binary Transformation Replacement",
              "STR" : "Set Transformation Replacement",
              "BTS" : "Binary Transformation Swap",
              "ATR" : "Aggregation Transformation Replacement",
              "OTI" : "Order Transformation Inversion",
              "DTI" : "Distinct Transformation Insertion",
              "DTD" : "Distinct Transformation Deletion",
              "NFTP" : "Negation of Filter Transformation Predicate",
              "UTS" : "Unary Transformation Swap"
            }
          },
          "totalDatasets" : 6,
          "totalTransformations" : 5,
          "totalMutants" : 19,
          "totalKilledMutants" : 14,
          "totalLivedMutants" : 0,
          "totalEquivalentMutants" : 5,
          "totalErrorMutants" : 0,
          "totalRemovedMutants" : 0,
          "mutationScore" : 1.0
        }
      ],
      "mutants" : [
        {
          "id" : 71,
          "originalProgramId" : 4,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 72,
          "originalProgramId" : 4,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 73,
          "originalProgramId" : 4,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 74,
          "originalProgramId" : 4,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 75,
          "originalProgramId" : 4,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 76,
          "originalProgramId" : 4,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    List[(Int, (Double, Double))]()\n  } }\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 77,
          "originalProgramId" : 4,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (inputParameter: (Int, Double)) => {\n    val originalFunction = ((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))(_)\n    val originalValue = originalFunction(inputParameter)\n    \"\"\n  } }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 78,
          "originalProgramId" : 4,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings).distinct()\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 79,
          "originalProgramId" : 4,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple).distinct()\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 80,
          "originalProgramId" : 4,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide).distinct()\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 81,
          "originalProgramId" : 4,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false).distinct()\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 82,
          "originalProgramId" : 4,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }.distinct()\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 83,
          "originalProgramId" : 4,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => firstParameter }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 84,
          "originalProgramId" : 4,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => secondParameter }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 85,
          "originalProgramId" : 4,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => {\n    val originalFunction = aggregateDoubleTuple(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 86,
          "originalProgramId" : 4,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => {\n    val originalFunction = aggregateDoubleTuple(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 87,
          "originalProgramId" : 4,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => {\n    val originalFunction = aggregateDoubleTuple(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 88,
          "originalProgramId" : 4,
          "mutationOperator" : "OTD",
          "mutationOperatorDescription" : "Order Transformation Deletion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 89,
          "originalProgramId" : 4,
          "mutationOperator" : "OTI",
          "mutationOperatorDescription" : "Order Transformation Inversion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(true)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 5,
          "UTD" : 2,
          "OTD" : 1,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 5,
          "OTI" : 1,
          "DTI" : 5,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 3,
          "UTD" : 2,
          "OTD" : 1,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 4,
          "OTI" : 1,
          "DTI" : 3,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 2,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 1,
          "OTI" : 0,
          "DTI" : 2,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalPrograms" : 1,
      "totalDatasets" : 6,
      "totalTransformations" : 5,
      "totalMutants" : 19,
      "totalKilledMutants" : 14,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 5,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 5,
      "source" : "target/transmut-20210306153959/mutated-src/example/MoviesRecommendation.scala",
      "sourceName" : "MoviesRecommendation",
      "programs" : [
        {
          "id" : 5,
          "programSourceId" : 5,
          "name" : "moviesSimilaritiesTable",
          "code" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "datasets" : [
            {
              "id" : 29,
              "name" : "inputRDD",
              "datasetType" : "RDD[String]",
              "inputDataset" : true,
              "outputDataset" : false
            },
            {
              "id" : 30,
              "name" : "ratings",
              "datasetType" : "RDD[(Int, (Int, Double))]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 31,
              "name" : "selfJoinRatings",
              "datasetType" : "RDD[(Int, ((Int, Double), (Int, Double)))]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 32,
              "name" : "filteredSelfJoinRatings",
              "datasetType" : "RDD[(Int, ((Int, Double), (Int, Double)))]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 33,
              "name" : "correlatedMovies",
              "datasetType" : "RDD[((Int, Int), (Double, Double))]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 34,
              "name" : "correlatedMoviesGroupedRatings",
              "datasetType" : "RDD[((Int, Int), Iterable[(Double, Double)])]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 35,
              "name" : "moviesSimilarities",
              "datasetType" : "RDD[((Int, Int), (Double, Int))]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 36,
              "name" : "sortedMoviesSimilarities",
              "datasetType" : "RDD[((Int, Int), (Double, Int))]",
              "inputDataset" : false,
              "outputDataset" : true
            }
          ],
          "transformations" : [
            {
              "id" : 24,
              "name" : "flatMap",
              "inputTypes" : [
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[(Int, (Int, Double))]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 25,
              "name" : "join",
              "inputTypes" : [
                "RDD[(Int, (Int, Double))]",
                "RDD[(Int, (Int, Double))]"
              ],
              "outputTypes" : [
                "RDD[(Int, ((Int, Double), (Int, Double)))]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 26,
              "name" : "filter",
              "inputTypes" : [
                "RDD[(Int, ((Int, Double), (Int, Double)))]"
              ],
              "outputTypes" : [
                "RDD[(Int, ((Int, Double), (Int, Double)))]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 27,
              "name" : "map",
              "inputTypes" : [
                "RDD[(Int, ((Int, Double), (Int, Double)))]"
              ],
              "outputTypes" : [
                "RDD[((Int, Int), (Double, Double))]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 28,
              "name" : "groupByKey",
              "inputTypes" : [
                "RDD[((Int, Int), (Double, Double))]"
              ],
              "outputTypes" : [
                "RDD[((Int, Int), Iterable[(Double, Double)])]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 29,
              "name" : "mapValues",
              "inputTypes" : [
                "RDD[((Int, Int), Iterable[(Double, Double)])]"
              ],
              "outputTypes" : [
                "RDD[((Int, Int), (Double, Int))]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 30,
              "name" : "sortByKey",
              "inputTypes" : [
                "RDD[((Int, Int), (Double, Int))]"
              ],
              "outputTypes" : [
                "RDD[((Int, Int), (Double, Int))]"
              ],
              "loadTransformation" : false
            }
          ],
          "edges" : [
            {
              "id" : 48,
              "datasetId" : 29,
              "transformationId" : 24,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 49,
              "datasetId" : 30,
              "transformationId" : 24,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 50,
              "datasetId" : 30,
              "transformationId" : 25,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 51,
              "datasetId" : 30,
              "transformationId" : 25,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 52,
              "datasetId" : 31,
              "transformationId" : 25,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 53,
              "datasetId" : 31,
              "transformationId" : 26,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 54,
              "datasetId" : 32,
              "transformationId" : 26,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 55,
              "datasetId" : 32,
              "transformationId" : 27,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 56,
              "datasetId" : 33,
              "transformationId" : 27,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 57,
              "datasetId" : 33,
              "transformationId" : 28,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 58,
              "datasetId" : 34,
              "transformationId" : 28,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 59,
              "datasetId" : 34,
              "transformationId" : 29,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 60,
              "datasetId" : 35,
              "transformationId" : 29,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 61,
              "datasetId" : 35,
              "transformationId" : 30,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 62,
              "datasetId" : 36,
              "transformationId" : 30,
              "direction" : "TransformationToDataset"
            }
          ],
          "mutants" : [
            {
              "id" : 90,
              "originalProgramId" : 5,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 91,
              "originalProgramId" : 5,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 92,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 93,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 94,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 95,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    List[(Int, (Int, Double))]()\n  } }\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 96,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((0, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 97,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((1, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 98,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((Int.MaxValue, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 99,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((Int.MinValue, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 100,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((-originalValue._1._1, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 101,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, 0), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 102,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, 1), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 103,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, Int.MaxValue), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 104,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, Int.MinValue), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 105,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, -originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 106,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (0d, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 107,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (1d, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 108,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (Double.MaxValue, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 109,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (Double.MinValue, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 110,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (-originalValue._2._1, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 111,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, 0d))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 112,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, 1d))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 113,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, Double.MaxValue))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 114,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, Double.MinValue))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 115,
              "originalProgramId" : 5,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, -originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 116,
              "originalProgramId" : 5,
              "mutationOperator" : "FTD",
              "mutationOperatorDescription" : "Filter Transformation Deletion",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 117,
              "originalProgramId" : 5,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings).distinct()\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 118,
              "originalProgramId" : 5,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings).distinct()\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 119,
              "originalProgramId" : 5,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates).distinct()\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 120,
              "originalProgramId" : 5,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs).distinct()\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 121,
              "originalProgramId" : 5,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey().distinct()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 122,
              "originalProgramId" : 5,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity).distinct()\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 123,
              "originalProgramId" : 5,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey().distinct()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 124,
              "originalProgramId" : 5,
              "mutationOperator" : "JTR",
              "mutationOperatorDescription" : "Join Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.leftOuterJoin(ratings).map(tuple => (tuple._1, (tuple._2._1, tuple._2._2.getOrElse((0, 0d)))))\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 125,
              "originalProgramId" : 5,
              "mutationOperator" : "JTR",
              "mutationOperatorDescription" : "Join Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.rightOuterJoin(ratings).map(tuple => (tuple._1, (tuple._2._1.getOrElse((0, 0d)), tuple._2._2)))\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 126,
              "originalProgramId" : 5,
              "mutationOperator" : "JTR",
              "mutationOperatorDescription" : "Join Transformation Replacement",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.fullOuterJoin(ratings).map(tuple => (tuple._1, (tuple._2._1.getOrElse((0, 0d)), tuple._2._2.getOrElse((0, 0d)))))\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 127,
              "originalProgramId" : 5,
              "mutationOperator" : "OTD",
              "mutationOperatorDescription" : "Order Transformation Deletion",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 128,
              "originalProgramId" : 5,
              "mutationOperator" : "NFTP",
              "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = removeDuplicates(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            },
            {
              "id" : 129,
              "originalProgramId" : 5,
              "mutationOperator" : "OTI",
              "mutationOperatorDescription" : "Order Transformation Inversion",
              "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey(false)\n  sortedMoviesSimilarities\n}",
              "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
              "status" : "Killed"
            }
          ],
          "removedMutants" : [
          ],
          "mutationOperatorsMetrics" : {
            "totalMutantsPerOperator" : {
              "FTD" : 1,
              "JTR" : 3,
              "UTR" : 0,
              "MTR" : 24,
              "UTD" : 2,
              "OTD" : 1,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 1,
              "DTI" : 7,
              "DTD" : 0,
              "NFTP" : 1,
              "UTS" : 0
            },
            "totalKilledMutantsPerOperator" : {
              "FTD" : 1,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 22,
              "UTD" : 2,
              "OTD" : 1,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 1,
              "DTI" : 2,
              "DTD" : 0,
              "NFTP" : 1,
              "UTS" : 0
            },
            "totalLivedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalEquivalentMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 3,
              "UTR" : 0,
              "MTR" : 2,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 5,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalErrorMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalRemovedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "descriptionPerOperator" : {
              "FTD" : "Filter Transformation Deletion",
              "JTR" : "Join Transformation Replacement",
              "UTR" : "Unary Transformation Replacement",
              "MTR" : "Mapping Transformation Replacement",
              "UTD" : "Unary Transformation Deletion",
              "OTD" : "Order Transformation Deletion",
              "BTR" : "Binary Transformation Replacement",
              "STR" : "Set Transformation Replacement",
              "BTS" : "Binary Transformation Swap",
              "ATR" : "Aggregation Transformation Replacement",
              "OTI" : "Order Transformation Inversion",
              "DTI" : "Distinct Transformation Insertion",
              "DTD" : "Distinct Transformation Deletion",
              "NFTP" : "Negation of Filter Transformation Predicate",
              "UTS" : "Unary Transformation Swap"
            }
          },
          "totalDatasets" : 8,
          "totalTransformations" : 7,
          "totalMutants" : 40,
          "totalKilledMutants" : 30,
          "totalLivedMutants" : 0,
          "totalEquivalentMutants" : 10,
          "totalErrorMutants" : 0,
          "totalRemovedMutants" : 0,
          "mutationScore" : 1.0
        },
        {
          "id" : 6,
          "programSourceId" : 5,
          "name" : "topNMoviesRecommendation",
          "code" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "datasets" : [
            {
              "id" : 37,
              "name" : "sortedMoviesSimilarities",
              "datasetType" : "RDD[((Int, Int), (Double, Int))]",
              "inputDataset" : true,
              "outputDataset" : false
            },
            {
              "id" : 38,
              "name" : "relevantMoviesSimilarities",
              "datasetType" : "RDD[((Int, Int), (Double, Int))]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 39,
              "name" : "recommendedMoviesPairs",
              "datasetType" : "RDD[(Int, (Int, Double))]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 40,
              "name" : "recommendedMoviesList",
              "datasetType" : "RDD[(Int, Iterable[(Int, Double)])]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 41,
              "name" : "sortedRecommendedMoviesList",
              "datasetType" : "RDD[(Int, Iterable[(Int, Double)])]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 42,
              "name" : "topNRecommendedMoviesByMovie",
              "datasetType" : "RDD[String]",
              "inputDataset" : false,
              "outputDataset" : true
            }
          ],
          "transformations" : [
            {
              "id" : 31,
              "name" : "filter",
              "inputTypes" : [
                "RDD[((Int, Int), (Double, Int))]"
              ],
              "outputTypes" : [
                "RDD[((Int, Int), (Double, Int))]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 32,
              "name" : "flatMap",
              "inputTypes" : [
                "RDD[((Int, Int), (Double, Int))]"
              ],
              "outputTypes" : [
                "RDD[(Int, (Int, Double))]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 33,
              "name" : "groupByKey",
              "inputTypes" : [
                "RDD[(Int, (Int, Double))]"
              ],
              "outputTypes" : [
                "RDD[(Int, Iterable[(Int, Double)])]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 34,
              "name" : "sortByKey",
              "inputTypes" : [
                "RDD[(Int, Iterable[(Int, Double)])]"
              ],
              "outputTypes" : [
                "RDD[(Int, Iterable[(Int, Double)])]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 35,
              "name" : "map",
              "inputTypes" : [
                "RDD[(Int, Iterable[(Int, Double)])]"
              ],
              "outputTypes" : [
                "RDD[String]"
              ],
              "loadTransformation" : false
            }
          ],
          "edges" : [
            {
              "id" : 63,
              "datasetId" : 37,
              "transformationId" : 31,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 64,
              "datasetId" : 38,
              "transformationId" : 31,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 65,
              "datasetId" : 38,
              "transformationId" : 32,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 66,
              "datasetId" : 39,
              "transformationId" : 32,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 67,
              "datasetId" : 39,
              "transformationId" : 33,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 68,
              "datasetId" : 40,
              "transformationId" : 33,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 69,
              "datasetId" : 40,
              "transformationId" : 34,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 70,
              "datasetId" : 41,
              "transformationId" : 34,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 71,
              "datasetId" : 41,
              "transformationId" : 35,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 72,
              "datasetId" : 42,
              "transformationId" : 35,
              "direction" : "TransformationToDataset"
            }
          ],
          "mutants" : [
            {
              "id" : 130,
              "originalProgramId" : 6,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
              "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
              "status" : "Killed"
            },
            {
              "id" : 131,
              "originalProgramId" : 6,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
              "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
              "status" : "Killed"
            },
            {
              "id" : 132,
              "originalProgramId" : 6,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = makeMoviesSimilaritiesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
              "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
              "status" : "Killed"
            },
            {
              "id" : 133,
              "originalProgramId" : 6,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = makeMoviesSimilaritiesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
              "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
              "status" : "Killed"
            },
            {
              "id" : 134,
              "originalProgramId" : 6,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = makeMoviesSimilaritiesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
              "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 135,
              "originalProgramId" : 6,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = makeMoviesSimilaritiesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    List[(Int, (Int, Double))]()\n  } }\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
              "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
              "status" : "Killed"
            },
            {
              "id" : 136,
              "originalProgramId" : 6,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (inputParameter: (Int, Iterable[(Int, Double)])) => {\n    val originalFunction = ((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))(_)\n    val originalValue = originalFunction(inputParameter)\n    \"\"\n  } }\n  topNRecommendedMoviesByMovie\n}",
              "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
              "status" : "Killed"
            },
            {
              "id" : 137,
              "originalProgramId" : 6,
              "mutationOperator" : "FTD",
              "mutationOperatorDescription" : "Filter Transformation Deletion",
              "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
              "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
              "status" : "Killed"
            },
            {
              "id" : 138,
              "originalProgramId" : 6,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }.distinct()\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
              "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 139,
              "originalProgramId" : 6,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs).distinct()\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
              "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 140,
              "originalProgramId" : 6,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey().distinct()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
              "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 141,
              "originalProgramId" : 6,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey().distinct()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
              "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
              "status" : "Killed"
            },
            {
              "id" : 142,
              "originalProgramId" : 6,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }.distinct()\n  topNRecommendedMoviesByMovie\n}",
              "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 143,
              "originalProgramId" : 6,
              "mutationOperator" : "OTD",
              "mutationOperatorDescription" : "Order Transformation Deletion",
              "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
              "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
              "status" : "Killed"
            },
            {
              "id" : 144,
              "originalProgramId" : 6,
              "mutationOperator" : "NFTP",
              "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
              "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = ((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
              "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
              "status" : "Killed"
            },
            {
              "id" : 145,
              "originalProgramId" : 6,
              "mutationOperator" : "OTI",
              "mutationOperatorDescription" : "Order Transformation Inversion",
              "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey(false)\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
              "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
              "status" : "Killed"
            }
          ],
          "removedMutants" : [
          ],
          "mutationOperatorsMetrics" : {
            "totalMutantsPerOperator" : {
              "FTD" : 1,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 5,
              "UTD" : 2,
              "OTD" : 1,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 1,
              "DTI" : 5,
              "DTD" : 0,
              "NFTP" : 1,
              "UTS" : 0
            },
            "totalKilledMutantsPerOperator" : {
              "FTD" : 1,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 4,
              "UTD" : 2,
              "OTD" : 1,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 1,
              "DTI" : 1,
              "DTD" : 0,
              "NFTP" : 1,
              "UTS" : 0
            },
            "totalLivedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalEquivalentMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 1,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 4,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalErrorMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalRemovedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "descriptionPerOperator" : {
              "FTD" : "Filter Transformation Deletion",
              "JTR" : "Join Transformation Replacement",
              "UTR" : "Unary Transformation Replacement",
              "MTR" : "Mapping Transformation Replacement",
              "UTD" : "Unary Transformation Deletion",
              "OTD" : "Order Transformation Deletion",
              "BTR" : "Binary Transformation Replacement",
              "STR" : "Set Transformation Replacement",
              "BTS" : "Binary Transformation Swap",
              "ATR" : "Aggregation Transformation Replacement",
              "OTI" : "Order Transformation Inversion",
              "DTI" : "Distinct Transformation Insertion",
              "DTD" : "Distinct Transformation Deletion",
              "NFTP" : "Negation of Filter Transformation Predicate",
              "UTS" : "Unary Transformation Swap"
            }
          },
          "totalDatasets" : 6,
          "totalTransformations" : 5,
          "totalMutants" : 16,
          "totalKilledMutants" : 11,
          "totalLivedMutants" : 0,
          "totalEquivalentMutants" : 5,
          "totalErrorMutants" : 0,
          "totalRemovedMutants" : 0,
          "mutationScore" : 1.0
        }
      ],
      "mutants" : [
        {
          "id" : 90,
          "originalProgramId" : 5,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 91,
          "originalProgramId" : 5,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 92,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 93,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 94,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 95,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    List[(Int, (Int, Double))]()\n  } }\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 96,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((0, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 97,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((1, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 98,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((Int.MaxValue, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 99,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((Int.MinValue, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 100,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((-originalValue._1._1, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 101,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, 0), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 102,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, 1), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 103,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, Int.MaxValue), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 104,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, Int.MinValue), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 105,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, -originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 106,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (0d, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 107,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (1d, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 108,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (Double.MaxValue, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 109,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (Double.MinValue, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 110,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (-originalValue._2._1, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 111,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, 0d))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 112,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, 1d))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 113,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, Double.MaxValue))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 114,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, Double.MinValue))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 115,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, -originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 116,
          "originalProgramId" : 5,
          "mutationOperator" : "FTD",
          "mutationOperatorDescription" : "Filter Transformation Deletion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 117,
          "originalProgramId" : 5,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings).distinct()\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 118,
          "originalProgramId" : 5,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings).distinct()\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 119,
          "originalProgramId" : 5,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates).distinct()\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 120,
          "originalProgramId" : 5,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs).distinct()\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 121,
          "originalProgramId" : 5,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey().distinct()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 122,
          "originalProgramId" : 5,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity).distinct()\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 123,
          "originalProgramId" : 5,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey().distinct()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 124,
          "originalProgramId" : 5,
          "mutationOperator" : "JTR",
          "mutationOperatorDescription" : "Join Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.leftOuterJoin(ratings).map(tuple => (tuple._1, (tuple._2._1, tuple._2._2.getOrElse((0, 0d)))))\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 125,
          "originalProgramId" : 5,
          "mutationOperator" : "JTR",
          "mutationOperatorDescription" : "Join Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.rightOuterJoin(ratings).map(tuple => (tuple._1, (tuple._2._1.getOrElse((0, 0d)), tuple._2._2)))\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 126,
          "originalProgramId" : 5,
          "mutationOperator" : "JTR",
          "mutationOperatorDescription" : "Join Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.fullOuterJoin(ratings).map(tuple => (tuple._1, (tuple._2._1.getOrElse((0, 0d)), tuple._2._2.getOrElse((0, 0d)))))\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 127,
          "originalProgramId" : 5,
          "mutationOperator" : "OTD",
          "mutationOperatorDescription" : "Order Transformation Deletion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 128,
          "originalProgramId" : 5,
          "mutationOperator" : "NFTP",
          "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = removeDuplicates(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 129,
          "originalProgramId" : 5,
          "mutationOperator" : "OTI",
          "mutationOperatorDescription" : "Order Transformation Inversion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey(false)\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 130,
          "originalProgramId" : 6,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 131,
          "originalProgramId" : 6,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 132,
          "originalProgramId" : 6,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = makeMoviesSimilaritiesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 133,
          "originalProgramId" : 6,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = makeMoviesSimilaritiesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 134,
          "originalProgramId" : 6,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = makeMoviesSimilaritiesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 135,
          "originalProgramId" : 6,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = makeMoviesSimilaritiesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    List[(Int, (Int, Double))]()\n  } }\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 136,
          "originalProgramId" : 6,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (inputParameter: (Int, Iterable[(Int, Double)])) => {\n    val originalFunction = ((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))(_)\n    val originalValue = originalFunction(inputParameter)\n    \"\"\n  } }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 137,
          "originalProgramId" : 6,
          "mutationOperator" : "FTD",
          "mutationOperatorDescription" : "Filter Transformation Deletion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 138,
          "originalProgramId" : 6,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }.distinct()\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 139,
          "originalProgramId" : 6,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs).distinct()\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 140,
          "originalProgramId" : 6,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey().distinct()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 141,
          "originalProgramId" : 6,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey().distinct()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 142,
          "originalProgramId" : 6,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }.distinct()\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 143,
          "originalProgramId" : 6,
          "mutationOperator" : "OTD",
          "mutationOperatorDescription" : "Order Transformation Deletion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 144,
          "originalProgramId" : 6,
          "mutationOperator" : "NFTP",
          "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = ((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 145,
          "originalProgramId" : 6,
          "mutationOperator" : "OTI",
          "mutationOperatorDescription" : "Order Transformation Inversion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey(false)\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 2,
          "JTR" : 3,
          "UTR" : 0,
          "MTR" : 29,
          "UTD" : 4,
          "OTD" : 2,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 2,
          "DTI" : 12,
          "DTD" : 0,
          "NFTP" : 2,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 2,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 26,
          "UTD" : 4,
          "OTD" : 2,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 2,
          "DTI" : 3,
          "DTD" : 0,
          "NFTP" : 2,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 3,
          "UTR" : 0,
          "MTR" : 3,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 9,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalPrograms" : 2,
      "totalDatasets" : 14,
      "totalTransformations" : 12,
      "totalMutants" : 56,
      "totalKilledMutants" : 41,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 15,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 6,
      "source" : "target/transmut-20210306153959/mutated-src/example/NasaApacheWebLogsAnalysis.scala",
      "sourceName" : "NasaApacheWebLogsAnalysis",
      "programs" : [
        {
          "id" : 7,
          "programSourceId" : 6,
          "name" : "sameHostProblem",
          "code" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "datasets" : [
            {
              "id" : 43,
              "name" : "firstLogs",
              "datasetType" : "RDD[String]",
              "inputDataset" : true,
              "outputDataset" : false
            },
            {
              "id" : 44,
              "name" : "secondLogs",
              "datasetType" : "RDD[String]",
              "inputDataset" : true,
              "outputDataset" : false
            },
            {
              "id" : 45,
              "name" : "firstHosts",
              "datasetType" : "RDD[String]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 46,
              "name" : "secondHosts",
              "datasetType" : "RDD[String]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 47,
              "name" : "intersection",
              "datasetType" : "RDD[String]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 48,
              "name" : "cleanedHostIntersection",
              "datasetType" : "RDD[String]",
              "inputDataset" : false,
              "outputDataset" : true
            }
          ],
          "transformations" : [
            {
              "id" : 36,
              "name" : "map",
              "inputTypes" : [
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[String]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 37,
              "name" : "map",
              "inputTypes" : [
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[String]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 38,
              "name" : "intersection",
              "inputTypes" : [
                "RDD[String]",
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[String]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 39,
              "name" : "filter",
              "inputTypes" : [
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[String]"
              ],
              "loadTransformation" : false
            }
          ],
          "edges" : [
            {
              "id" : 73,
              "datasetId" : 43,
              "transformationId" : 36,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 74,
              "datasetId" : 45,
              "transformationId" : 36,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 75,
              "datasetId" : 44,
              "transformationId" : 37,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 76,
              "datasetId" : 46,
              "transformationId" : 37,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 77,
              "datasetId" : 45,
              "transformationId" : 38,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 78,
              "datasetId" : 46,
              "transformationId" : 38,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 79,
              "datasetId" : 47,
              "transformationId" : 38,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 80,
              "datasetId" : 47,
              "transformationId" : 39,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 81,
              "datasetId" : 48,
              "transformationId" : 39,
              "direction" : "TransformationToDataset"
            }
          ],
          "mutants" : [
            {
              "id" : 146,
              "originalProgramId" : 7,
              "mutationOperator" : "UTS",
              "mutationOperatorDescription" : "Unary Transformation Swap",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 147,
              "originalProgramId" : 7,
              "mutationOperator" : "UTS",
              "mutationOperatorDescription" : "Unary Transformation Swap",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.filter(host => isNotHeaderHost(host))\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.map(parseLogs)\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            },
            {
              "id" : 148,
              "originalProgramId" : 7,
              "mutationOperator" : "UTS",
              "mutationOperatorDescription" : "Unary Transformation Swap",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.filter(host => isNotHeaderHost(host))\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.map(parseLogs)\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            },
            {
              "id" : 149,
              "originalProgramId" : 7,
              "mutationOperator" : "UTR",
              "mutationOperatorDescription" : "Unary Transformation Replacement",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 150,
              "originalProgramId" : 7,
              "mutationOperator" : "UTR",
              "mutationOperatorDescription" : "Unary Transformation Replacement",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.filter(host => isNotHeaderHost(host))\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            },
            {
              "id" : 151,
              "originalProgramId" : 7,
              "mutationOperator" : "UTR",
              "mutationOperatorDescription" : "Unary Transformation Replacement",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 152,
              "originalProgramId" : 7,
              "mutationOperator" : "UTR",
              "mutationOperatorDescription" : "Unary Transformation Replacement",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.filter(host => isNotHeaderHost(host))\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            },
            {
              "id" : 153,
              "originalProgramId" : 7,
              "mutationOperator" : "UTR",
              "mutationOperatorDescription" : "Unary Transformation Replacement",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.map(parseLogs)\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            },
            {
              "id" : 154,
              "originalProgramId" : 7,
              "mutationOperator" : "UTR",
              "mutationOperatorDescription" : "Unary Transformation Replacement",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.map(parseLogs)\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            },
            {
              "id" : 155,
              "originalProgramId" : 7,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            },
            {
              "id" : 156,
              "originalProgramId" : 7,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            },
            {
              "id" : 157,
              "originalProgramId" : 7,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            },
            {
              "id" : 158,
              "originalProgramId" : 7,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map { (inputParameter: String) => {\n    val originalFunction = parseLogs(_)\n    val originalValue = originalFunction(inputParameter)\n    \"\"\n  } }\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            },
            {
              "id" : 159,
              "originalProgramId" : 7,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map { (inputParameter: String) => {\n    val originalFunction = parseLogs(_)\n    val originalValue = originalFunction(inputParameter)\n    \"\"\n  } }\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            },
            {
              "id" : 160,
              "originalProgramId" : 7,
              "mutationOperator" : "FTD",
              "mutationOperatorDescription" : "Filter Transformation Deletion",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            },
            {
              "id" : 161,
              "originalProgramId" : 7,
              "mutationOperator" : "STR",
              "mutationOperatorDescription" : "Set Transformation Replacement",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.union(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            },
            {
              "id" : 162,
              "originalProgramId" : 7,
              "mutationOperator" : "STR",
              "mutationOperatorDescription" : "Set Transformation Replacement",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.subtract(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            },
            {
              "id" : 163,
              "originalProgramId" : 7,
              "mutationOperator" : "STR",
              "mutationOperatorDescription" : "Set Transformation Replacement",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            },
            {
              "id" : 164,
              "originalProgramId" : 7,
              "mutationOperator" : "STR",
              "mutationOperatorDescription" : "Set Transformation Replacement",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = secondHosts\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            },
            {
              "id" : 165,
              "originalProgramId" : 7,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs).distinct()\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 166,
              "originalProgramId" : 7,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs).distinct()\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 167,
              "originalProgramId" : 7,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts).distinct()\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 168,
              "originalProgramId" : 7,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host)).distinct()\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 169,
              "originalProgramId" : 7,
              "mutationOperator" : "NFTP",
              "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
              "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter { (inputParameter: String) => {\n    val originalFunction = (host => isNotHeaderHost(host))(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  cleanedHostIntersection\n}",
              "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
              "status" : "Killed"
            }
          ],
          "removedMutants" : [
          ],
          "mutationOperatorsMetrics" : {
            "totalMutantsPerOperator" : {
              "FTD" : 1,
              "JTR" : 0,
              "UTR" : 6,
              "MTR" : 2,
              "UTD" : 3,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 4,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 4,
              "DTD" : 0,
              "NFTP" : 1,
              "UTS" : 3
            },
            "totalKilledMutantsPerOperator" : {
              "FTD" : 1,
              "JTR" : 0,
              "UTR" : 4,
              "MTR" : 2,
              "UTD" : 3,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 4,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 1,
              "UTS" : 2
            },
            "totalLivedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalEquivalentMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 2,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 4,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 1
            },
            "totalErrorMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalRemovedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "descriptionPerOperator" : {
              "FTD" : "Filter Transformation Deletion",
              "JTR" : "Join Transformation Replacement",
              "UTR" : "Unary Transformation Replacement",
              "MTR" : "Mapping Transformation Replacement",
              "UTD" : "Unary Transformation Deletion",
              "OTD" : "Order Transformation Deletion",
              "BTR" : "Binary Transformation Replacement",
              "STR" : "Set Transformation Replacement",
              "BTS" : "Binary Transformation Swap",
              "ATR" : "Aggregation Transformation Replacement",
              "OTI" : "Order Transformation Inversion",
              "DTI" : "Distinct Transformation Insertion",
              "DTD" : "Distinct Transformation Deletion",
              "NFTP" : "Negation of Filter Transformation Predicate",
              "UTS" : "Unary Transformation Swap"
            }
          },
          "totalDatasets" : 6,
          "totalTransformations" : 4,
          "totalMutants" : 24,
          "totalKilledMutants" : 17,
          "totalLivedMutants" : 0,
          "totalEquivalentMutants" : 7,
          "totalErrorMutants" : 0,
          "totalRemovedMutants" : 0,
          "mutationScore" : 1.0
        },
        {
          "id" : 8,
          "programSourceId" : 6,
          "name" : "unionLogsProblem",
          "code" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "datasets" : [
            {
              "id" : 49,
              "name" : "firstLogs",
              "datasetType" : "RDD[String]",
              "inputDataset" : true,
              "outputDataset" : false
            },
            {
              "id" : 50,
              "name" : "secondLogs",
              "datasetType" : "RDD[String]",
              "inputDataset" : true,
              "outputDataset" : false
            },
            {
              "id" : 51,
              "name" : "aggregatedLogLines",
              "datasetType" : "RDD[String]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 52,
              "name" : "uniqueLogLines",
              "datasetType" : "RDD[String]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 53,
              "name" : "cleanLogLines",
              "datasetType" : "RDD[String]",
              "inputDataset" : false,
              "outputDataset" : true
            }
          ],
          "transformations" : [
            {
              "id" : 40,
              "name" : "union",
              "inputTypes" : [
                "RDD[String]",
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[String]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 41,
              "name" : "distinct",
              "inputTypes" : [
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[String]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 42,
              "name" : "filter",
              "inputTypes" : [
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[String]"
              ],
              "loadTransformation" : false
            }
          ],
          "edges" : [
            {
              "id" : 82,
              "datasetId" : 49,
              "transformationId" : 40,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 83,
              "datasetId" : 50,
              "transformationId" : 40,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 84,
              "datasetId" : 51,
              "transformationId" : 40,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 85,
              "datasetId" : 51,
              "transformationId" : 41,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 86,
              "datasetId" : 52,
              "transformationId" : 41,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 87,
              "datasetId" : 52,
              "transformationId" : 42,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 88,
              "datasetId" : 53,
              "transformationId" : 42,
              "direction" : "TransformationToDataset"
            }
          ],
          "mutants" : [
            {
              "id" : 170,
              "originalProgramId" : 8,
              "mutationOperator" : "UTS",
              "mutationOperatorDescription" : "Unary Transformation Swap",
              "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.filter(line => isNotHeader(line))\n  val cleanLogLines: RDD[String] = uniqueLogLines.distinct()\n  cleanLogLines\n}",
              "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 171,
              "originalProgramId" : 8,
              "mutationOperator" : "UTR",
              "mutationOperatorDescription" : "Unary Transformation Replacement",
              "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.filter(line => isNotHeader(line))\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
              "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
              "status" : "Killed"
            },
            {
              "id" : 172,
              "originalProgramId" : 8,
              "mutationOperator" : "UTR",
              "mutationOperatorDescription" : "Unary Transformation Replacement",
              "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.distinct()\n  cleanLogLines\n}",
              "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
              "status" : "Killed"
            },
            {
              "id" : 173,
              "originalProgramId" : 8,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
              "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
              "status" : "Killed"
            },
            {
              "id" : 174,
              "originalProgramId" : 8,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines\n  cleanLogLines\n}",
              "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
              "status" : "Killed"
            },
            {
              "id" : 175,
              "originalProgramId" : 8,
              "mutationOperator" : "FTD",
              "mutationOperatorDescription" : "Filter Transformation Deletion",
              "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines\n  cleanLogLines\n}",
              "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
              "status" : "Killed"
            },
            {
              "id" : 176,
              "originalProgramId" : 8,
              "mutationOperator" : "STR",
              "mutationOperatorDescription" : "Set Transformation Replacement",
              "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.intersection(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
              "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
              "status" : "Killed"
            },
            {
              "id" : 177,
              "originalProgramId" : 8,
              "mutationOperator" : "STR",
              "mutationOperatorDescription" : "Set Transformation Replacement",
              "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.subtract(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
              "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
              "status" : "Killed"
            },
            {
              "id" : 178,
              "originalProgramId" : 8,
              "mutationOperator" : "STR",
              "mutationOperatorDescription" : "Set Transformation Replacement",
              "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
              "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
              "status" : "Killed"
            },
            {
              "id" : 179,
              "originalProgramId" : 8,
              "mutationOperator" : "STR",
              "mutationOperatorDescription" : "Set Transformation Replacement",
              "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = secondLogs\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
              "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
              "status" : "Killed"
            },
            {
              "id" : 180,
              "originalProgramId" : 8,
              "mutationOperator" : "DTD",
              "mutationOperatorDescription" : "Distinct Transformation Deletion",
              "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
              "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
              "status" : "Killed"
            },
            {
              "id" : 181,
              "originalProgramId" : 8,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs).distinct()\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
              "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 182,
              "originalProgramId" : 8,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line)).distinct()\n  cleanLogLines\n}",
              "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 183,
              "originalProgramId" : 8,
              "mutationOperator" : "NFTP",
              "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
              "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter { (inputParameter: String) => {\n    val originalFunction = (line => isNotHeader(line))(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  cleanLogLines\n}",
              "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
              "status" : "Killed"
            }
          ],
          "removedMutants" : [
          ],
          "mutationOperatorsMetrics" : {
            "totalMutantsPerOperator" : {
              "FTD" : 1,
              "JTR" : 0,
              "UTR" : 2,
              "MTR" : 0,
              "UTD" : 2,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 4,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 2,
              "DTD" : 1,
              "NFTP" : 1,
              "UTS" : 1
            },
            "totalKilledMutantsPerOperator" : {
              "FTD" : 1,
              "JTR" : 0,
              "UTR" : 2,
              "MTR" : 0,
              "UTD" : 2,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 4,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 1,
              "NFTP" : 1,
              "UTS" : 0
            },
            "totalLivedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalEquivalentMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 2,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 1
            },
            "totalErrorMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalRemovedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "descriptionPerOperator" : {
              "FTD" : "Filter Transformation Deletion",
              "JTR" : "Join Transformation Replacement",
              "UTR" : "Unary Transformation Replacement",
              "MTR" : "Mapping Transformation Replacement",
              "UTD" : "Unary Transformation Deletion",
              "OTD" : "Order Transformation Deletion",
              "BTR" : "Binary Transformation Replacement",
              "STR" : "Set Transformation Replacement",
              "BTS" : "Binary Transformation Swap",
              "ATR" : "Aggregation Transformation Replacement",
              "OTI" : "Order Transformation Inversion",
              "DTI" : "Distinct Transformation Insertion",
              "DTD" : "Distinct Transformation Deletion",
              "NFTP" : "Negation of Filter Transformation Predicate",
              "UTS" : "Unary Transformation Swap"
            }
          },
          "totalDatasets" : 5,
          "totalTransformations" : 3,
          "totalMutants" : 14,
          "totalKilledMutants" : 11,
          "totalLivedMutants" : 0,
          "totalEquivalentMutants" : 3,
          "totalErrorMutants" : 0,
          "totalRemovedMutants" : 0,
          "mutationScore" : 1.0
        }
      ],
      "mutants" : [
        {
          "id" : 146,
          "originalProgramId" : 7,
          "mutationOperator" : "UTS",
          "mutationOperatorDescription" : "Unary Transformation Swap",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 147,
          "originalProgramId" : 7,
          "mutationOperator" : "UTS",
          "mutationOperatorDescription" : "Unary Transformation Swap",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.filter(host => isNotHeaderHost(host))\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.map(parseLogs)\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 148,
          "originalProgramId" : 7,
          "mutationOperator" : "UTS",
          "mutationOperatorDescription" : "Unary Transformation Swap",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.filter(host => isNotHeaderHost(host))\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.map(parseLogs)\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 149,
          "originalProgramId" : 7,
          "mutationOperator" : "UTR",
          "mutationOperatorDescription" : "Unary Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 150,
          "originalProgramId" : 7,
          "mutationOperator" : "UTR",
          "mutationOperatorDescription" : "Unary Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.filter(host => isNotHeaderHost(host))\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 151,
          "originalProgramId" : 7,
          "mutationOperator" : "UTR",
          "mutationOperatorDescription" : "Unary Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 152,
          "originalProgramId" : 7,
          "mutationOperator" : "UTR",
          "mutationOperatorDescription" : "Unary Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.filter(host => isNotHeaderHost(host))\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 153,
          "originalProgramId" : 7,
          "mutationOperator" : "UTR",
          "mutationOperatorDescription" : "Unary Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.map(parseLogs)\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 154,
          "originalProgramId" : 7,
          "mutationOperator" : "UTR",
          "mutationOperatorDescription" : "Unary Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.map(parseLogs)\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 155,
          "originalProgramId" : 7,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 156,
          "originalProgramId" : 7,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 157,
          "originalProgramId" : 7,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 158,
          "originalProgramId" : 7,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map { (inputParameter: String) => {\n    val originalFunction = parseLogs(_)\n    val originalValue = originalFunction(inputParameter)\n    \"\"\n  } }\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 159,
          "originalProgramId" : 7,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map { (inputParameter: String) => {\n    val originalFunction = parseLogs(_)\n    val originalValue = originalFunction(inputParameter)\n    \"\"\n  } }\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 160,
          "originalProgramId" : 7,
          "mutationOperator" : "FTD",
          "mutationOperatorDescription" : "Filter Transformation Deletion",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 161,
          "originalProgramId" : 7,
          "mutationOperator" : "STR",
          "mutationOperatorDescription" : "Set Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.union(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 162,
          "originalProgramId" : 7,
          "mutationOperator" : "STR",
          "mutationOperatorDescription" : "Set Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.subtract(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 163,
          "originalProgramId" : 7,
          "mutationOperator" : "STR",
          "mutationOperatorDescription" : "Set Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 164,
          "originalProgramId" : 7,
          "mutationOperator" : "STR",
          "mutationOperatorDescription" : "Set Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = secondHosts\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 165,
          "originalProgramId" : 7,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs).distinct()\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 166,
          "originalProgramId" : 7,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs).distinct()\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 167,
          "originalProgramId" : 7,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts).distinct()\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 168,
          "originalProgramId" : 7,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host)).distinct()\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 169,
          "originalProgramId" : 7,
          "mutationOperator" : "NFTP",
          "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter { (inputParameter: String) => {\n    val originalFunction = (host => isNotHeaderHost(host))(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 170,
          "originalProgramId" : 8,
          "mutationOperator" : "UTS",
          "mutationOperatorDescription" : "Unary Transformation Swap",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.filter(line => isNotHeader(line))\n  val cleanLogLines: RDD[String] = uniqueLogLines.distinct()\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 171,
          "originalProgramId" : 8,
          "mutationOperator" : "UTR",
          "mutationOperatorDescription" : "Unary Transformation Replacement",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.filter(line => isNotHeader(line))\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 172,
          "originalProgramId" : 8,
          "mutationOperator" : "UTR",
          "mutationOperatorDescription" : "Unary Transformation Replacement",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.distinct()\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 173,
          "originalProgramId" : 8,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 174,
          "originalProgramId" : 8,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 175,
          "originalProgramId" : 8,
          "mutationOperator" : "FTD",
          "mutationOperatorDescription" : "Filter Transformation Deletion",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 176,
          "originalProgramId" : 8,
          "mutationOperator" : "STR",
          "mutationOperatorDescription" : "Set Transformation Replacement",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.intersection(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 177,
          "originalProgramId" : 8,
          "mutationOperator" : "STR",
          "mutationOperatorDescription" : "Set Transformation Replacement",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.subtract(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 178,
          "originalProgramId" : 8,
          "mutationOperator" : "STR",
          "mutationOperatorDescription" : "Set Transformation Replacement",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 179,
          "originalProgramId" : 8,
          "mutationOperator" : "STR",
          "mutationOperatorDescription" : "Set Transformation Replacement",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = secondLogs\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 180,
          "originalProgramId" : 8,
          "mutationOperator" : "DTD",
          "mutationOperatorDescription" : "Distinct Transformation Deletion",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 181,
          "originalProgramId" : 8,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs).distinct()\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 182,
          "originalProgramId" : 8,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line)).distinct()\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 183,
          "originalProgramId" : 8,
          "mutationOperator" : "NFTP",
          "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter { (inputParameter: String) => {\n    val originalFunction = (line => isNotHeader(line))(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 2,
          "JTR" : 0,
          "UTR" : 8,
          "MTR" : 2,
          "UTD" : 5,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 8,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 6,
          "DTD" : 1,
          "NFTP" : 2,
          "UTS" : 4
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 2,
          "JTR" : 0,
          "UTR" : 6,
          "MTR" : 2,
          "UTD" : 5,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 8,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 1,
          "NFTP" : 2,
          "UTS" : 2
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 2,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 6,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 2
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalPrograms" : 2,
      "totalDatasets" : 11,
      "totalTransformations" : 7,
      "totalMutants" : 38,
      "totalKilledMutants" : 28,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 10,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 7,
      "source" : "target/transmut-20210306153959/mutated-src/example/NGramsCount.scala",
      "sourceName" : "NGramsCount",
      "programs" : [
        {
          "id" : 9,
          "programSourceId" : 7,
          "name" : "countNGrams",
          "code" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "datasets" : [
            {
              "id" : 54,
              "name" : "input",
              "datasetType" : "RDD[String]",
              "inputDataset" : true,
              "outputDataset" : false
            },
            {
              "id" : 55,
              "name" : "sentences",
              "datasetType" : "RDD[String]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 56,
              "name" : "ngrams",
              "datasetType" : "RDD[List[String]]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 57,
              "name" : "ngramsFiltered",
              "datasetType" : "RDD[List[String]]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 58,
              "name" : "ngramsPairs",
              "datasetType" : "RDD[(List[String], Int)]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 59,
              "name" : "ngramsCount",
              "datasetType" : "RDD[(List[String], Int)]",
              "inputDataset" : false,
              "outputDataset" : true
            }
          ],
          "transformations" : [
            {
              "id" : 43,
              "name" : "flatMap",
              "inputTypes" : [
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[String]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 44,
              "name" : "flatMap",
              "inputTypes" : [
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[List[String]]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 45,
              "name" : "filter",
              "inputTypes" : [
                "RDD[List[String]]"
              ],
              "outputTypes" : [
                "RDD[List[String]]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 46,
              "name" : "map",
              "inputTypes" : [
                "RDD[List[String]]"
              ],
              "outputTypes" : [
                "RDD[(List[String], Int)]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 47,
              "name" : "reduceByKey",
              "inputTypes" : [
                "RDD[(List[String], Int)]"
              ],
              "outputTypes" : [
                "RDD[(List[String], Int)]"
              ],
              "loadTransformation" : false
            }
          ],
          "edges" : [
            {
              "id" : 89,
              "datasetId" : 54,
              "transformationId" : 43,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 90,
              "datasetId" : 55,
              "transformationId" : 43,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 91,
              "datasetId" : 55,
              "transformationId" : 44,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 92,
              "datasetId" : 56,
              "transformationId" : 44,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 93,
              "datasetId" : 56,
              "transformationId" : 45,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 94,
              "datasetId" : 57,
              "transformationId" : 45,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 95,
              "datasetId" : 57,
              "transformationId" : 46,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 96,
              "datasetId" : 58,
              "transformationId" : 46,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 97,
              "datasetId" : 58,
              "transformationId" : 47,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 98,
              "datasetId" : 59,
              "transformationId" : 47,
              "direction" : "TransformationToDataset"
            }
          ],
          "mutants" : [
            {
              "id" : 184,
              "originalProgramId" : 9,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 185,
              "originalProgramId" : 9,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 186,
              "originalProgramId" : 9,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 187,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap { (inputParameter: String) => {\n    val originalFunction = tokenize(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 188,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap { (inputParameter: String) => {\n    val originalFunction = tokenize(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 189,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap { (inputParameter: String) => {\n    val originalFunction = tokenize(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 190,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap { (inputParameter: String) => {\n    val originalFunction = tokenize(_)\n    val originalValue = originalFunction(inputParameter)\n    List[String]()\n  } }\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 191,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (inputParameter: String) => {\n    val originalFunction = ((s: String) => nGrams(s))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 192,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (inputParameter: String) => {\n    val originalFunction = ((s: String) => nGrams(s))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 193,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (inputParameter: String) => {\n    val originalFunction = ((s: String) => nGrams(s))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 194,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (inputParameter: String) => {\n    val originalFunction = ((s: String) => nGrams(s))(_)\n    val originalValue = originalFunction(inputParameter)\n    List[List[String]]()\n  } }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 195,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (List[String](originalValue._1.head), originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 196,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1.tail, originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 197,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1.reverse, originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 198,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (List[String](), originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 199,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 0)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 200,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 1)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 201,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MaxValue)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 202,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MinValue)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 203,
              "originalProgramId" : 9,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, -originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 204,
              "originalProgramId" : 9,
              "mutationOperator" : "FTD",
              "mutationOperatorDescription" : "Filter Transformation Deletion",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 205,
              "originalProgramId" : 9,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize).distinct()\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 206,
              "originalProgramId" : 9,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }.distinct()\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 207,
              "originalProgramId" : 9,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }.distinct()\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 208,
              "originalProgramId" : 9,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }.distinct()\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 209,
              "originalProgramId" : 9,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }.distinct()\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 210,
              "originalProgramId" : 9,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => firstParameter }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 211,
              "originalProgramId" : 9,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => secondParameter }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 212,
              "originalProgramId" : 9,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((x: Int, y: Int) => x + y)(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 213,
              "originalProgramId" : 9,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((x: Int, y: Int) => x + y)(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            },
            {
              "id" : 214,
              "originalProgramId" : 9,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((x: Int, y: Int) => x + y)(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Equivalent"
            },
            {
              "id" : 215,
              "originalProgramId" : 9,
              "mutationOperator" : "NFTP",
              "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
              "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => filterEmpty(ngram))(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
              "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
              "status" : "Killed"
            }
          ],
          "removedMutants" : [
          ],
          "mutationOperatorsMetrics" : {
            "totalMutantsPerOperator" : {
              "FTD" : 1,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 17,
              "UTD" : 3,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 5,
              "OTI" : 0,
              "DTI" : 5,
              "DTD" : 0,
              "NFTP" : 1,
              "UTS" : 0
            },
            "totalKilledMutantsPerOperator" : {
              "FTD" : 1,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 14,
              "UTD" : 3,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 4,
              "OTI" : 0,
              "DTI" : 4,
              "DTD" : 0,
              "NFTP" : 1,
              "UTS" : 0
            },
            "totalLivedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalEquivalentMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 3,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 1,
              "OTI" : 0,
              "DTI" : 1,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalErrorMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalRemovedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "descriptionPerOperator" : {
              "FTD" : "Filter Transformation Deletion",
              "JTR" : "Join Transformation Replacement",
              "UTR" : "Unary Transformation Replacement",
              "MTR" : "Mapping Transformation Replacement",
              "UTD" : "Unary Transformation Deletion",
              "OTD" : "Order Transformation Deletion",
              "BTR" : "Binary Transformation Replacement",
              "STR" : "Set Transformation Replacement",
              "BTS" : "Binary Transformation Swap",
              "ATR" : "Aggregation Transformation Replacement",
              "OTI" : "Order Transformation Inversion",
              "DTI" : "Distinct Transformation Insertion",
              "DTD" : "Distinct Transformation Deletion",
              "NFTP" : "Negation of Filter Transformation Predicate",
              "UTS" : "Unary Transformation Swap"
            }
          },
          "totalDatasets" : 6,
          "totalTransformations" : 5,
          "totalMutants" : 32,
          "totalKilledMutants" : 27,
          "totalLivedMutants" : 0,
          "totalEquivalentMutants" : 5,
          "totalErrorMutants" : 0,
          "totalRemovedMutants" : 0,
          "mutationScore" : 1.0
        }
      ],
      "mutants" : [
        {
          "id" : 184,
          "originalProgramId" : 9,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 185,
          "originalProgramId" : 9,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 186,
          "originalProgramId" : 9,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 187,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap { (inputParameter: String) => {\n    val originalFunction = tokenize(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 188,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap { (inputParameter: String) => {\n    val originalFunction = tokenize(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 189,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap { (inputParameter: String) => {\n    val originalFunction = tokenize(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 190,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap { (inputParameter: String) => {\n    val originalFunction = tokenize(_)\n    val originalValue = originalFunction(inputParameter)\n    List[String]()\n  } }\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 191,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (inputParameter: String) => {\n    val originalFunction = ((s: String) => nGrams(s))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 192,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (inputParameter: String) => {\n    val originalFunction = ((s: String) => nGrams(s))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 193,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (inputParameter: String) => {\n    val originalFunction = ((s: String) => nGrams(s))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 194,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (inputParameter: String) => {\n    val originalFunction = ((s: String) => nGrams(s))(_)\n    val originalValue = originalFunction(inputParameter)\n    List[List[String]]()\n  } }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 195,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (List[String](originalValue._1.head), originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 196,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1.tail, originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 197,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1.reverse, originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 198,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (List[String](), originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 199,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 0)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 200,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 1)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 201,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MaxValue)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 202,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MinValue)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 203,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, -originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 204,
          "originalProgramId" : 9,
          "mutationOperator" : "FTD",
          "mutationOperatorDescription" : "Filter Transformation Deletion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 205,
          "originalProgramId" : 9,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize).distinct()\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 206,
          "originalProgramId" : 9,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }.distinct()\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 207,
          "originalProgramId" : 9,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }.distinct()\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 208,
          "originalProgramId" : 9,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }.distinct()\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 209,
          "originalProgramId" : 9,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }.distinct()\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 210,
          "originalProgramId" : 9,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => firstParameter }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 211,
          "originalProgramId" : 9,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => secondParameter }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 212,
          "originalProgramId" : 9,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((x: Int, y: Int) => x + y)(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 213,
          "originalProgramId" : 9,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((x: Int, y: Int) => x + y)(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 214,
          "originalProgramId" : 9,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((x: Int, y: Int) => x + y)(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 215,
          "originalProgramId" : 9,
          "mutationOperator" : "NFTP",
          "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => filterEmpty(ngram))(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 17,
          "UTD" : 3,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 5,
          "OTI" : 0,
          "DTI" : 5,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 14,
          "UTD" : 3,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 4,
          "OTI" : 0,
          "DTI" : 4,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 3,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 1,
          "OTI" : 0,
          "DTI" : 1,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalPrograms" : 1,
      "totalDatasets" : 6,
      "totalTransformations" : 5,
      "totalMutants" : 32,
      "totalKilledMutants" : 27,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 5,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 8,
      "source" : "target/transmut-20210306153959/mutated-src/example/ScanQuery.scala",
      "sourceName" : "ScanQuery",
      "programs" : [
        {
          "id" : 10,
          "programSourceId" : 8,
          "name" : "scan",
          "code" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "datasets" : [
            {
              "id" : 60,
              "name" : "input",
              "datasetType" : "RDD[String]",
              "inputDataset" : true,
              "outputDataset" : false
            },
            {
              "id" : 61,
              "name" : "rankings",
              "datasetType" : "RDD[Ranking]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 62,
              "name" : "filteredRankings",
              "datasetType" : "RDD[Ranking]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 63,
              "name" : "results",
              "datasetType" : "RDD[(String, Int)]",
              "inputDataset" : false,
              "outputDataset" : true
            }
          ],
          "transformations" : [
            {
              "id" : 48,
              "name" : "map",
              "inputTypes" : [
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[Ranking]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 49,
              "name" : "filter",
              "inputTypes" : [
                "RDD[Ranking]"
              ],
              "outputTypes" : [
                "RDD[Ranking]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 50,
              "name" : "map",
              "inputTypes" : [
                "RDD[Ranking]"
              ],
              "outputTypes" : [
                "RDD[(String, Int)]"
              ],
              "loadTransformation" : false
            }
          ],
          "edges" : [
            {
              "id" : 99,
              "datasetId" : 60,
              "transformationId" : 48,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 100,
              "datasetId" : 61,
              "transformationId" : 48,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 101,
              "datasetId" : 61,
              "transformationId" : 49,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 102,
              "datasetId" : 62,
              "transformationId" : 49,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 103,
              "datasetId" : 62,
              "transformationId" : 50,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 104,
              "datasetId" : 63,
              "transformationId" : 50,
              "direction" : "TransformationToDataset"
            }
          ],
          "mutants" : [
            {
              "id" : 216,
              "originalProgramId" : 10,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
              "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 217,
              "originalProgramId" : 10,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map { (inputParameter: String) => {\n    val originalFunction = parseRankings(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[Ranking]\n  } }\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
              "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 218,
              "originalProgramId" : 10,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  results\n}",
              "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 219,
              "originalProgramId" : 10,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 0)\n  } }\n  results\n}",
              "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 220,
              "originalProgramId" : 10,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 1)\n  } }\n  results\n}",
              "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 221,
              "originalProgramId" : 10,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MaxValue)\n  } }\n  results\n}",
              "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 222,
              "originalProgramId" : 10,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MinValue)\n  } }\n  results\n}",
              "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 223,
              "originalProgramId" : 10,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, -originalValue._2)\n  } }\n  results\n}",
              "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 224,
              "originalProgramId" : 10,
              "mutationOperator" : "FTD",
              "mutationOperatorDescription" : "Filter Transformation Deletion",
              "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
              "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 225,
              "originalProgramId" : 10,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings).distinct()\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
              "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 226,
              "originalProgramId" : 10,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings).distinct()\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
              "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 227,
              "originalProgramId" : 10,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple).distinct()\n  results\n}",
              "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
              "status" : "Killed"
            },
            {
              "id" : 228,
              "originalProgramId" : 10,
              "mutationOperator" : "NFTP",
              "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
              "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter { (inputParameter: Ranking) => {\n    val originalFunction = filterRankings(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
              "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
              "status" : "Killed"
            }
          ],
          "removedMutants" : [
          ],
          "mutationOperatorsMetrics" : {
            "totalMutantsPerOperator" : {
              "FTD" : 1,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 7,
              "UTD" : 1,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 3,
              "DTD" : 0,
              "NFTP" : 1,
              "UTS" : 0
            },
            "totalKilledMutantsPerOperator" : {
              "FTD" : 1,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 7,
              "UTD" : 1,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 3,
              "DTD" : 0,
              "NFTP" : 1,
              "UTS" : 0
            },
            "totalLivedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalEquivalentMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalErrorMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalRemovedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "descriptionPerOperator" : {
              "FTD" : "Filter Transformation Deletion",
              "JTR" : "Join Transformation Replacement",
              "UTR" : "Unary Transformation Replacement",
              "MTR" : "Mapping Transformation Replacement",
              "UTD" : "Unary Transformation Deletion",
              "OTD" : "Order Transformation Deletion",
              "BTR" : "Binary Transformation Replacement",
              "STR" : "Set Transformation Replacement",
              "BTS" : "Binary Transformation Swap",
              "ATR" : "Aggregation Transformation Replacement",
              "OTI" : "Order Transformation Inversion",
              "DTI" : "Distinct Transformation Insertion",
              "DTD" : "Distinct Transformation Deletion",
              "NFTP" : "Negation of Filter Transformation Predicate",
              "UTS" : "Unary Transformation Swap"
            }
          },
          "totalDatasets" : 4,
          "totalTransformations" : 3,
          "totalMutants" : 13,
          "totalKilledMutants" : 13,
          "totalLivedMutants" : 0,
          "totalEquivalentMutants" : 0,
          "totalErrorMutants" : 0,
          "totalRemovedMutants" : 0,
          "mutationScore" : 1.0
        }
      ],
      "mutants" : [
        {
          "id" : 216,
          "originalProgramId" : 10,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 217,
          "originalProgramId" : 10,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map { (inputParameter: String) => {\n    val originalFunction = parseRankings(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[Ranking]\n  } }\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 218,
          "originalProgramId" : 10,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 219,
          "originalProgramId" : 10,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 0)\n  } }\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 220,
          "originalProgramId" : 10,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 1)\n  } }\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 221,
          "originalProgramId" : 10,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MaxValue)\n  } }\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 222,
          "originalProgramId" : 10,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MinValue)\n  } }\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 223,
          "originalProgramId" : 10,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, -originalValue._2)\n  } }\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 224,
          "originalProgramId" : 10,
          "mutationOperator" : "FTD",
          "mutationOperatorDescription" : "Filter Transformation Deletion",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 225,
          "originalProgramId" : 10,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings).distinct()\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 226,
          "originalProgramId" : 10,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings).distinct()\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 227,
          "originalProgramId" : 10,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple).distinct()\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 228,
          "originalProgramId" : 10,
          "mutationOperator" : "NFTP",
          "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter { (inputParameter: Ranking) => {\n    val originalFunction = filterRankings(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 7,
          "UTD" : 1,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 3,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 7,
          "UTD" : 1,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 3,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalPrograms" : 1,
      "totalDatasets" : 4,
      "totalTransformations" : 3,
      "totalMutants" : 13,
      "totalKilledMutants" : 13,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 0,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 9,
      "source" : "target/transmut-20210306153959/mutated-src/example/WordCount.scala",
      "sourceName" : "WordCount",
      "programs" : [
        {
          "id" : 11,
          "programSourceId" : 9,
          "name" : "wordCount",
          "code" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "datasets" : [
            {
              "id" : 64,
              "name" : "input",
              "datasetType" : "RDD[String]",
              "inputDataset" : true,
              "outputDataset" : false
            },
            {
              "id" : 65,
              "name" : "words",
              "datasetType" : "RDD[String]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 66,
              "name" : "pairs",
              "datasetType" : "RDD[(String, Int)]",
              "inputDataset" : false,
              "outputDataset" : false
            },
            {
              "id" : 67,
              "name" : "counts",
              "datasetType" : "RDD[(String, Int)]",
              "inputDataset" : false,
              "outputDataset" : true
            }
          ],
          "transformations" : [
            {
              "id" : 51,
              "name" : "flatMap",
              "inputTypes" : [
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[String]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 52,
              "name" : "map",
              "inputTypes" : [
                "RDD[String]"
              ],
              "outputTypes" : [
                "RDD[(String, Int)]"
              ],
              "loadTransformation" : false
            },
            {
              "id" : 53,
              "name" : "reduceByKey",
              "inputTypes" : [
                "RDD[(String, Int)]"
              ],
              "outputTypes" : [
                "RDD[(String, Int)]"
              ],
              "loadTransformation" : false
            }
          ],
          "edges" : [
            {
              "id" : 105,
              "datasetId" : 64,
              "transformationId" : 51,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 106,
              "datasetId" : 65,
              "transformationId" : 51,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 107,
              "datasetId" : 65,
              "transformationId" : 52,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 108,
              "datasetId" : 66,
              "transformationId" : 52,
              "direction" : "TransformationToDataset"
            },
            {
              "id" : 109,
              "datasetId" : 66,
              "transformationId" : 53,
              "direction" : "DatasetToTransformation"
            },
            {
              "id" : 110,
              "datasetId" : 67,
              "transformationId" : 53,
              "direction" : "TransformationToDataset"
            }
          ],
          "mutants" : [
            {
              "id" : 229,
              "originalProgramId" : 11,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Killed"
            },
            {
              "id" : 230,
              "originalProgramId" : 11,
              "mutationOperator" : "UTD",
              "mutationOperatorDescription" : "Unary Transformation Deletion",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Killed"
            },
            {
              "id" : 231,
              "originalProgramId" : 11,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (inputParameter: String) => {\n    val originalFunction = ((line: String) => line.split(\" \"))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Killed"
            },
            {
              "id" : 232,
              "originalProgramId" : 11,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (inputParameter: String) => {\n    val originalFunction = ((line: String) => line.split(\" \"))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Killed"
            },
            {
              "id" : 233,
              "originalProgramId" : 11,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (inputParameter: String) => {\n    val originalFunction = ((line: String) => line.split(\" \"))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Equivalent"
            },
            {
              "id" : 234,
              "originalProgramId" : 11,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (inputParameter: String) => {\n    val originalFunction = ((line: String) => line.split(\" \"))(_)\n    val originalValue = originalFunction(inputParameter)\n    List[String]()\n  } }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Killed"
            },
            {
              "id" : 235,
              "originalProgramId" : 11,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Killed"
            },
            {
              "id" : 236,
              "originalProgramId" : 11,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 0)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Killed"
            },
            {
              "id" : 237,
              "originalProgramId" : 11,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 1)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Equivalent"
            },
            {
              "id" : 238,
              "originalProgramId" : 11,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MaxValue)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Killed"
            },
            {
              "id" : 239,
              "originalProgramId" : 11,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MinValue)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Killed"
            },
            {
              "id" : 240,
              "originalProgramId" : 11,
              "mutationOperator" : "MTR",
              "mutationOperatorDescription" : "Mapping Transformation Replacement",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, -originalValue._2)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Killed"
            },
            {
              "id" : 241,
              "originalProgramId" : 11,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }.distinct()\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Killed"
            },
            {
              "id" : 242,
              "originalProgramId" : 11,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }.distinct()\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Killed"
            },
            {
              "id" : 243,
              "originalProgramId" : 11,
              "mutationOperator" : "DTI",
              "mutationOperatorDescription" : "Distinct Transformation Insertion",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }.distinct()\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Equivalent"
            },
            {
              "id" : 244,
              "originalProgramId" : 11,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => firstParameter }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Killed"
            },
            {
              "id" : 245,
              "originalProgramId" : 11,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => secondParameter }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Killed"
            },
            {
              "id" : 246,
              "originalProgramId" : 11,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((a: Int, b: Int) => a + b)(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Killed"
            },
            {
              "id" : 247,
              "originalProgramId" : 11,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((a: Int, b: Int) => a + b)(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Killed"
            },
            {
              "id" : 248,
              "originalProgramId" : 11,
              "mutationOperator" : "ATR",
              "mutationOperatorDescription" : "Aggregation Transformation Replacement",
              "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((a: Int, b: Int) => a + b)(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  counts\n}",
              "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
              "status" : "Equivalent"
            }
          ],
          "removedMutants" : [
          ],
          "mutationOperatorsMetrics" : {
            "totalMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 10,
              "UTD" : 2,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 5,
              "OTI" : 0,
              "DTI" : 3,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalKilledMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 8,
              "UTD" : 2,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 4,
              "OTI" : 0,
              "DTI" : 2,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalLivedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalEquivalentMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 2,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 1,
              "OTI" : 0,
              "DTI" : 1,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalErrorMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "totalRemovedMutantsPerOperator" : {
              "FTD" : 0,
              "JTR" : 0,
              "UTR" : 0,
              "MTR" : 0,
              "UTD" : 0,
              "OTD" : 0,
              "BTR" : 0,
              "STR" : 0,
              "BTS" : 0,
              "ATR" : 0,
              "OTI" : 0,
              "DTI" : 0,
              "DTD" : 0,
              "NFTP" : 0,
              "UTS" : 0
            },
            "descriptionPerOperator" : {
              "FTD" : "Filter Transformation Deletion",
              "JTR" : "Join Transformation Replacement",
              "UTR" : "Unary Transformation Replacement",
              "MTR" : "Mapping Transformation Replacement",
              "UTD" : "Unary Transformation Deletion",
              "OTD" : "Order Transformation Deletion",
              "BTR" : "Binary Transformation Replacement",
              "STR" : "Set Transformation Replacement",
              "BTS" : "Binary Transformation Swap",
              "ATR" : "Aggregation Transformation Replacement",
              "OTI" : "Order Transformation Inversion",
              "DTI" : "Distinct Transformation Insertion",
              "DTD" : "Distinct Transformation Deletion",
              "NFTP" : "Negation of Filter Transformation Predicate",
              "UTS" : "Unary Transformation Swap"
            }
          },
          "totalDatasets" : 4,
          "totalTransformations" : 3,
          "totalMutants" : 20,
          "totalKilledMutants" : 16,
          "totalLivedMutants" : 0,
          "totalEquivalentMutants" : 4,
          "totalErrorMutants" : 0,
          "totalRemovedMutants" : 0,
          "mutationScore" : 1.0
        }
      ],
      "mutants" : [
        {
          "id" : 229,
          "originalProgramId" : 11,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 230,
          "originalProgramId" : 11,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 231,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (inputParameter: String) => {\n    val originalFunction = ((line: String) => line.split(\" \"))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 232,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (inputParameter: String) => {\n    val originalFunction = ((line: String) => line.split(\" \"))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 233,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (inputParameter: String) => {\n    val originalFunction = ((line: String) => line.split(\" \"))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Equivalent"
        },
        {
          "id" : 234,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (inputParameter: String) => {\n    val originalFunction = ((line: String) => line.split(\" \"))(_)\n    val originalValue = originalFunction(inputParameter)\n    List[String]()\n  } }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 235,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 236,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 0)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 237,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 1)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Equivalent"
        },
        {
          "id" : 238,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MaxValue)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 239,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MinValue)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 240,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, -originalValue._2)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 241,
          "originalProgramId" : 11,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }.distinct()\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 242,
          "originalProgramId" : 11,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }.distinct()\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 243,
          "originalProgramId" : 11,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }.distinct()\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Equivalent"
        },
        {
          "id" : 244,
          "originalProgramId" : 11,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => firstParameter }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 245,
          "originalProgramId" : 11,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => secondParameter }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 246,
          "originalProgramId" : 11,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((a: Int, b: Int) => a + b)(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 247,
          "originalProgramId" : 11,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((a: Int, b: Int) => a + b)(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 248,
          "originalProgramId" : 11,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((a: Int, b: Int) => a + b)(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Equivalent"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 10,
          "UTD" : 2,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 5,
          "OTI" : 0,
          "DTI" : 3,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 8,
          "UTD" : 2,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 4,
          "OTI" : 0,
          "DTI" : 2,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 2,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 1,
          "OTI" : 0,
          "DTI" : 1,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalPrograms" : 1,
      "totalDatasets" : 4,
      "totalTransformations" : 3,
      "totalMutants" : 20,
      "totalKilledMutants" : 16,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 4,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    }
  ],
  "programs" : [
    {
      "id" : 1,
      "programSourceId" : 1,
      "name" : "aggregation",
      "code" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "datasets" : [
        {
          "id" : 1,
          "name" : "input",
          "datasetType" : "RDD[String]",
          "inputDataset" : true,
          "outputDataset" : false
        },
        {
          "id" : 2,
          "name" : "userVisits",
          "datasetType" : "RDD[UserVisit]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 3,
          "name" : "userVisitsTuples",
          "datasetType" : "RDD[(String, Float)]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 4,
          "name" : "results",
          "datasetType" : "RDD[(String, Float)]",
          "inputDataset" : false,
          "outputDataset" : true
        }
      ],
      "transformations" : [
        {
          "id" : 1,
          "name" : "map",
          "inputTypes" : [
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[UserVisit]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 2,
          "name" : "map",
          "inputTypes" : [
            "RDD[UserVisit]"
          ],
          "outputTypes" : [
            "RDD[(String, Float)]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 3,
          "name" : "reduceByKey",
          "inputTypes" : [
            "RDD[(String, Float)]"
          ],
          "outputTypes" : [
            "RDD[(String, Float)]"
          ],
          "loadTransformation" : false
        }
      ],
      "edges" : [
        {
          "id" : 1,
          "datasetId" : 1,
          "transformationId" : 1,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 2,
          "datasetId" : 2,
          "transformationId" : 1,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 3,
          "datasetId" : 2,
          "transformationId" : 2,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 4,
          "datasetId" : 3,
          "transformationId" : 2,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 5,
          "datasetId" : 3,
          "transformationId" : 3,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 6,
          "datasetId" : 4,
          "transformationId" : 3,
          "direction" : "TransformationToDataset"
        }
      ],
      "mutants" : [
        {
          "id" : 1,
          "originalProgramId" : 1,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 2,
          "originalProgramId" : 1,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map { (inputParameter: String) => {\n    val originalFunction = parseUserVisits(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[UserVisit]\n  } }\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 3,
          "originalProgramId" : 1,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 4,
          "originalProgramId" : 1,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 0f)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 5,
          "originalProgramId" : 1,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 1f)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 6,
          "originalProgramId" : 1,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Float.MaxValue)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 7,
          "originalProgramId" : 1,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Float.MinValue)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 8,
          "originalProgramId" : 1,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, -originalValue._2)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 9,
          "originalProgramId" : 1,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits).distinct()\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 10,
          "originalProgramId" : 1,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple).distinct()\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 11,
          "originalProgramId" : 1,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }.distinct()\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 12,
          "originalProgramId" : 1,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => firstParameter }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 13,
          "originalProgramId" : 1,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => secondParameter }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 14,
          "originalProgramId" : 1,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => {\n    val originalFunction = ((x: Float, y: Float) => x + y)(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 15,
          "originalProgramId" : 1,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => {\n    val originalFunction = ((x: Float, y: Float) => x + y)(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 16,
          "originalProgramId" : 1,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => {\n    val originalFunction = ((x: Float, y: Float) => x + y)(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  results\n}",
          "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
          "status" : "Equivalent"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 7,
          "UTD" : 1,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 5,
          "OTI" : 0,
          "DTI" : 3,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 7,
          "UTD" : 1,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 4,
          "OTI" : 0,
          "DTI" : 2,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 1,
          "OTI" : 0,
          "DTI" : 1,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalDatasets" : 4,
      "totalTransformations" : 3,
      "totalMutants" : 16,
      "totalKilledMutants" : 14,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 2,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 2,
      "programSourceId" : 2,
      "name" : "distinctUserVisitsPerPage",
      "code" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "datasets" : [
        {
          "id" : 5,
          "name" : "input",
          "datasetType" : "RDD[String]",
          "inputDataset" : true,
          "outputDataset" : false
        },
        {
          "id" : 6,
          "name" : "userVisits",
          "datasetType" : "RDD[UserVisit]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 7,
          "name" : "userAccesses",
          "datasetType" : "RDD[(String, String)]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 8,
          "name" : "mapedUserAccess",
          "datasetType" : "RDD[(String, Set[String])]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 9,
          "name" : "distinctSites",
          "datasetType" : "RDD[(String, Set[String])]",
          "inputDataset" : false,
          "outputDataset" : true
        }
      ],
      "transformations" : [
        {
          "id" : 4,
          "name" : "map",
          "inputTypes" : [
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[UserVisit]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 5,
          "name" : "map",
          "inputTypes" : [
            "RDD[UserVisit]"
          ],
          "outputTypes" : [
            "RDD[(String, String)]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 6,
          "name" : "map",
          "inputTypes" : [
            "RDD[(String, String)]"
          ],
          "outputTypes" : [
            "RDD[(String, Set[String])]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 7,
          "name" : "reduceByKey",
          "inputTypes" : [
            "RDD[(String, Set[String])]"
          ],
          "outputTypes" : [
            "RDD[(String, Set[String])]"
          ],
          "loadTransformation" : false
        }
      ],
      "edges" : [
        {
          "id" : 7,
          "datasetId" : 5,
          "transformationId" : 4,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 8,
          "datasetId" : 6,
          "transformationId" : 4,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 9,
          "datasetId" : 6,
          "transformationId" : 5,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 10,
          "datasetId" : 7,
          "transformationId" : 5,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 11,
          "datasetId" : 7,
          "transformationId" : 6,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 12,
          "datasetId" : 8,
          "transformationId" : 6,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 13,
          "datasetId" : 8,
          "transformationId" : 7,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 14,
          "datasetId" : 9,
          "transformationId" : 7,
          "direction" : "TransformationToDataset"
        }
      ],
      "mutants" : [
        {
          "id" : 17,
          "originalProgramId" : 2,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 18,
          "originalProgramId" : 2,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map { (inputParameter: String) => {\n    val originalFunction = parseUserVisits(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[UserVisit]\n  } }\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 19,
          "originalProgramId" : 2,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 20,
          "originalProgramId" : 2,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, \"\")\n  } }\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 21,
          "originalProgramId" : 2,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map { (inputParameter: (String, String)) => {\n    val originalFunction = mapSourceIPToSet(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 22,
          "originalProgramId" : 2,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map { (inputParameter: (String, String)) => {\n    val originalFunction = mapSourceIPToSet(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Set[String](originalValue._2.head))\n  } }\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 23,
          "originalProgramId" : 2,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map { (inputParameter: (String, String)) => {\n    val originalFunction = mapSourceIPToSet(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, originalValue._2.tail)\n  } }\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 24,
          "originalProgramId" : 2,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map { (inputParameter: (String, String)) => {\n    val originalFunction = mapSourceIPToSet(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Set[String]())\n  } }\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 25,
          "originalProgramId" : 2,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits).distinct()\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 26,
          "originalProgramId" : 2,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple).distinct()\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 27,
          "originalProgramId" : 2,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet).distinct()\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 28,
          "originalProgramId" : 2,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion).distinct()\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 29,
          "originalProgramId" : 2,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => firstParameter }\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 30,
          "originalProgramId" : 2,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => secondParameter }\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 31,
          "originalProgramId" : 2,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => {\n    val originalFunction = setUnion(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 32,
          "originalProgramId" : 2,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => {\n    val originalFunction = setUnion(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Killed"
        },
        {
          "id" : 33,
          "originalProgramId" : 2,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => {\n    val originalFunction = setUnion(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  distinctSites\n}",
          "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
          "status" : "Equivalent"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 7,
          "UTD" : 1,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 5,
          "OTI" : 0,
          "DTI" : 4,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 6,
          "UTD" : 1,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 4,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 1,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 1,
          "OTI" : 0,
          "DTI" : 4,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalDatasets" : 5,
      "totalTransformations" : 4,
      "totalMutants" : 17,
      "totalKilledMutants" : 11,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 6,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 3,
      "programSourceId" : 3,
      "name" : "join",
      "code" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "datasets" : [
        {
          "id" : 10,
          "name" : "rankingsLines",
          "datasetType" : "RDD[String]",
          "inputDataset" : true,
          "outputDataset" : false
        },
        {
          "id" : 11,
          "name" : "userVisitsLines",
          "datasetType" : "RDD[String]",
          "inputDataset" : true,
          "outputDataset" : false
        },
        {
          "id" : 12,
          "name" : "rankings",
          "datasetType" : "RDD[Ranking]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 13,
          "name" : "userVisits",
          "datasetType" : "RDD[UserVisit]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 14,
          "name" : "filteredUV",
          "datasetType" : "RDD[UserVisit]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 15,
          "name" : "subqueryUV",
          "datasetType" : "RDD[(String, UserVisit)]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 16,
          "name" : "subqueryR",
          "datasetType" : "RDD[(String, Ranking)]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 17,
          "name" : "subqueryJoin",
          "datasetType" : "RDD[(String, (Ranking, UserVisit))]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 18,
          "name" : "subqueryJoinValues",
          "datasetType" : "RDD[(Ranking, UserVisit)]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 19,
          "name" : "subquerySelect",
          "datasetType" : "RDD[(String, (Float, Int))]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 20,
          "name" : "subqueryGroup",
          "datasetType" : "RDD[(String, Iterable[(Float, Int)])]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 21,
          "name" : "subqueryAggregation",
          "datasetType" : "RDD[Tuple3[String, Float, Int]]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 22,
          "name" : "results",
          "datasetType" : "RDD[Tuple3[String, Float, Int]]",
          "inputDataset" : false,
          "outputDataset" : true
        }
      ],
      "transformations" : [
        {
          "id" : 8,
          "name" : "map",
          "inputTypes" : [
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[Ranking]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 9,
          "name" : "map",
          "inputTypes" : [
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[UserVisit]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 10,
          "name" : "filter",
          "inputTypes" : [
            "RDD[UserVisit]"
          ],
          "outputTypes" : [
            "RDD[UserVisit]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 11,
          "name" : "map",
          "inputTypes" : [
            "RDD[UserVisit]"
          ],
          "outputTypes" : [
            "RDD[(String, UserVisit)]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 12,
          "name" : "map",
          "inputTypes" : [
            "RDD[Ranking]"
          ],
          "outputTypes" : [
            "RDD[(String, Ranking)]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 13,
          "name" : "join",
          "inputTypes" : [
            "RDD[(String, Ranking)]",
            "RDD[(String, UserVisit)]"
          ],
          "outputTypes" : [
            "RDD[(String, (Ranking, UserVisit))]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 14,
          "name" : "values",
          "inputTypes" : [
            "RDD[(String, (Ranking, UserVisit))]"
          ],
          "outputTypes" : [
            "RDD[(Ranking, UserVisit)]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 15,
          "name" : "map",
          "inputTypes" : [
            "RDD[(Ranking, UserVisit)]"
          ],
          "outputTypes" : [
            "RDD[(String, (Float, Int))]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 16,
          "name" : "groupByKey",
          "inputTypes" : [
            "RDD[(String, (Float, Int))]"
          ],
          "outputTypes" : [
            "RDD[(String, Iterable[(Float, Int)])]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 17,
          "name" : "map",
          "inputTypes" : [
            "RDD[(String, Iterable[(Float, Int)])]"
          ],
          "outputTypes" : [
            "RDD[Tuple3[String, Float, Int]]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 18,
          "name" : "sortBy",
          "inputTypes" : [
            "RDD[Tuple3[String, Float, Int]]"
          ],
          "outputTypes" : [
            "RDD[Tuple3[String, Float, Int]]"
          ],
          "loadTransformation" : false
        }
      ],
      "edges" : [
        {
          "id" : 15,
          "datasetId" : 10,
          "transformationId" : 8,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 16,
          "datasetId" : 12,
          "transformationId" : 8,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 17,
          "datasetId" : 11,
          "transformationId" : 9,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 18,
          "datasetId" : 13,
          "transformationId" : 9,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 19,
          "datasetId" : 13,
          "transformationId" : 10,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 20,
          "datasetId" : 14,
          "transformationId" : 10,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 21,
          "datasetId" : 14,
          "transformationId" : 11,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 22,
          "datasetId" : 15,
          "transformationId" : 11,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 23,
          "datasetId" : 12,
          "transformationId" : 12,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 24,
          "datasetId" : 16,
          "transformationId" : 12,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 25,
          "datasetId" : 16,
          "transformationId" : 13,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 26,
          "datasetId" : 15,
          "transformationId" : 13,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 27,
          "datasetId" : 17,
          "transformationId" : 13,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 28,
          "datasetId" : 17,
          "transformationId" : 14,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 29,
          "datasetId" : 18,
          "transformationId" : 14,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 30,
          "datasetId" : 18,
          "transformationId" : 15,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 31,
          "datasetId" : 19,
          "transformationId" : 15,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 32,
          "datasetId" : 19,
          "transformationId" : 16,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 33,
          "datasetId" : 20,
          "transformationId" : 16,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 34,
          "datasetId" : 20,
          "transformationId" : 17,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 35,
          "datasetId" : 21,
          "transformationId" : 17,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 36,
          "datasetId" : 21,
          "transformationId" : 18,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 37,
          "datasetId" : 22,
          "transformationId" : 18,
          "direction" : "TransformationToDataset"
        }
      ],
      "mutants" : [
        {
          "id" : 34,
          "originalProgramId" : 3,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 35,
          "originalProgramId" : 3,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 36,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map { (inputParameter: String) => {\n    val originalFunction = parseRankings(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[Ranking]\n  } }\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 37,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map { (inputParameter: String) => {\n    val originalFunction = parseUserVisits(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[UserVisit]\n  } }\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 38,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 39,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, null.asInstanceOf[UserVisit])\n  } }\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 40,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 41,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, null.asInstanceOf[Ranking])\n  } }\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 42,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 43,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (0f, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 44,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (1f, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 45,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (Float.MaxValue, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 46,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (Float.MinValue, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 47,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (-originalValue._2._1, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 48,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, 0))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 49,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, 1))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 50,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, Int.MaxValue))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 51,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, Int.MinValue))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 52,
          "originalProgramId" : 3,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, -originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 53,
          "originalProgramId" : 3,
          "mutationOperator" : "FTD",
          "mutationOperatorDescription" : "Filter Transformation Deletion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 54,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings).distinct()\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 55,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits).distinct()\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 56,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange).distinct()\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 57,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple).distinct()\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 58,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple).distinct()\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 59,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV).distinct()\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 60,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values.distinct()\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 61,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple).distinct()\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 62,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey().distinct()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 63,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation).distinct()\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 64,
          "originalProgramId" : 3,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false).distinct()\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 65,
          "originalProgramId" : 3,
          "mutationOperator" : "JTR",
          "mutationOperatorDescription" : "Join Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.leftOuterJoin(subqueryUV).map(tuple => (tuple._1, (tuple._2._1, tuple._2._2.getOrElse(null.asInstanceOf[UserVisit]))))\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 66,
          "originalProgramId" : 3,
          "mutationOperator" : "JTR",
          "mutationOperatorDescription" : "Join Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.rightOuterJoin(subqueryUV).map(tuple => (tuple._1, (tuple._2._1.getOrElse(null.asInstanceOf[Ranking]), tuple._2._2)))\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 67,
          "originalProgramId" : 3,
          "mutationOperator" : "JTR",
          "mutationOperatorDescription" : "Join Transformation Replacement",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.fullOuterJoin(subqueryUV).map(tuple => (tuple._1, (tuple._2._1.getOrElse(null.asInstanceOf[Ranking]), tuple._2._2.getOrElse(null.asInstanceOf[UserVisit]))))\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 68,
          "originalProgramId" : 3,
          "mutationOperator" : "OTD",
          "mutationOperatorDescription" : "Order Transformation Deletion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 69,
          "originalProgramId" : 3,
          "mutationOperator" : "NFTP",
          "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter { (inputParameter: UserVisit) => {\n    val originalFunction = filterUserVisitsDateRange(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 70,
          "originalProgramId" : 3,
          "mutationOperator" : "OTI",
          "mutationOperatorDescription" : "Order Transformation Inversion",
          "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, true)\n  results\n}",
          "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
          "status" : "Killed"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 3,
          "UTR" : 0,
          "MTR" : 17,
          "UTD" : 2,
          "OTD" : 1,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 1,
          "DTI" : 11,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 3,
          "UTR" : 0,
          "MTR" : 17,
          "UTD" : 2,
          "OTD" : 1,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 1,
          "DTI" : 9,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 2,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalDatasets" : 13,
      "totalTransformations" : 11,
      "totalMutants" : 37,
      "totalKilledMutants" : 35,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 2,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 4,
      "programSourceId" : 4,
      "name" : "moviesRatingsAverage",
      "code" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "datasets" : [
        {
          "id" : 23,
          "name" : "inputRDD",
          "datasetType" : "RDD[String]",
          "inputDataset" : true,
          "outputDataset" : false
        },
        {
          "id" : 24,
          "name" : "ratings",
          "datasetType" : "RDD[(Int, (Double, Double))]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 25,
          "name" : "ratingsSum",
          "datasetType" : "RDD[(Int, (Double, Double))]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 26,
          "name" : "ratingsAverage",
          "datasetType" : "RDD[(Int, Double)]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 27,
          "name" : "ratingsAverageSorted",
          "datasetType" : "RDD[(Int, Double)]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 28,
          "name" : "resultsCVS",
          "datasetType" : "RDD[String]",
          "inputDataset" : false,
          "outputDataset" : true
        }
      ],
      "transformations" : [
        {
          "id" : 19,
          "name" : "flatMap",
          "inputTypes" : [
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[(Int, (Double, Double))]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 20,
          "name" : "reduceByKey",
          "inputTypes" : [
            "RDD[(Int, (Double, Double))]"
          ],
          "outputTypes" : [
            "RDD[(Int, (Double, Double))]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 21,
          "name" : "mapValues",
          "inputTypes" : [
            "RDD[(Int, (Double, Double))]"
          ],
          "outputTypes" : [
            "RDD[(Int, Double)]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 22,
          "name" : "sortByKey",
          "inputTypes" : [
            "RDD[(Int, Double)]"
          ],
          "outputTypes" : [
            "RDD[(Int, Double)]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 23,
          "name" : "map",
          "inputTypes" : [
            "RDD[(Int, Double)]"
          ],
          "outputTypes" : [
            "RDD[String]"
          ],
          "loadTransformation" : false
        }
      ],
      "edges" : [
        {
          "id" : 38,
          "datasetId" : 23,
          "transformationId" : 19,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 39,
          "datasetId" : 24,
          "transformationId" : 19,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 40,
          "datasetId" : 24,
          "transformationId" : 20,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 41,
          "datasetId" : 25,
          "transformationId" : 20,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 42,
          "datasetId" : 25,
          "transformationId" : 21,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 43,
          "datasetId" : 26,
          "transformationId" : 21,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 44,
          "datasetId" : 26,
          "transformationId" : 22,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 45,
          "datasetId" : 27,
          "transformationId" : 22,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 46,
          "datasetId" : 27,
          "transformationId" : 23,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 47,
          "datasetId" : 28,
          "transformationId" : 23,
          "direction" : "TransformationToDataset"
        }
      ],
      "mutants" : [
        {
          "id" : 71,
          "originalProgramId" : 4,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 72,
          "originalProgramId" : 4,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 73,
          "originalProgramId" : 4,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 74,
          "originalProgramId" : 4,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 75,
          "originalProgramId" : 4,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 76,
          "originalProgramId" : 4,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    List[(Int, (Double, Double))]()\n  } }\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 77,
          "originalProgramId" : 4,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (inputParameter: (Int, Double)) => {\n    val originalFunction = ((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))(_)\n    val originalValue = originalFunction(inputParameter)\n    \"\"\n  } }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 78,
          "originalProgramId" : 4,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings).distinct()\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 79,
          "originalProgramId" : 4,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple).distinct()\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 80,
          "originalProgramId" : 4,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide).distinct()\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 81,
          "originalProgramId" : 4,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false).distinct()\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 82,
          "originalProgramId" : 4,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }.distinct()\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 83,
          "originalProgramId" : 4,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => firstParameter }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 84,
          "originalProgramId" : 4,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => secondParameter }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 85,
          "originalProgramId" : 4,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => {\n    val originalFunction = aggregateDoubleTuple(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 86,
          "originalProgramId" : 4,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => {\n    val originalFunction = aggregateDoubleTuple(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 87,
          "originalProgramId" : 4,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => {\n    val originalFunction = aggregateDoubleTuple(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 88,
          "originalProgramId" : 4,
          "mutationOperator" : "OTD",
          "mutationOperatorDescription" : "Order Transformation Deletion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        },
        {
          "id" : 89,
          "originalProgramId" : 4,
          "mutationOperator" : "OTI",
          "mutationOperatorDescription" : "Order Transformation Inversion",
          "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(true)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
          "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
          "status" : "Killed"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 5,
          "UTD" : 2,
          "OTD" : 1,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 5,
          "OTI" : 1,
          "DTI" : 5,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 3,
          "UTD" : 2,
          "OTD" : 1,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 4,
          "OTI" : 1,
          "DTI" : 3,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 2,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 1,
          "OTI" : 0,
          "DTI" : 2,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalDatasets" : 6,
      "totalTransformations" : 5,
      "totalMutants" : 19,
      "totalKilledMutants" : 14,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 5,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 5,
      "programSourceId" : 5,
      "name" : "moviesSimilaritiesTable",
      "code" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "datasets" : [
        {
          "id" : 29,
          "name" : "inputRDD",
          "datasetType" : "RDD[String]",
          "inputDataset" : true,
          "outputDataset" : false
        },
        {
          "id" : 30,
          "name" : "ratings",
          "datasetType" : "RDD[(Int, (Int, Double))]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 31,
          "name" : "selfJoinRatings",
          "datasetType" : "RDD[(Int, ((Int, Double), (Int, Double)))]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 32,
          "name" : "filteredSelfJoinRatings",
          "datasetType" : "RDD[(Int, ((Int, Double), (Int, Double)))]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 33,
          "name" : "correlatedMovies",
          "datasetType" : "RDD[((Int, Int), (Double, Double))]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 34,
          "name" : "correlatedMoviesGroupedRatings",
          "datasetType" : "RDD[((Int, Int), Iterable[(Double, Double)])]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 35,
          "name" : "moviesSimilarities",
          "datasetType" : "RDD[((Int, Int), (Double, Int))]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 36,
          "name" : "sortedMoviesSimilarities",
          "datasetType" : "RDD[((Int, Int), (Double, Int))]",
          "inputDataset" : false,
          "outputDataset" : true
        }
      ],
      "transformations" : [
        {
          "id" : 24,
          "name" : "flatMap",
          "inputTypes" : [
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[(Int, (Int, Double))]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 25,
          "name" : "join",
          "inputTypes" : [
            "RDD[(Int, (Int, Double))]",
            "RDD[(Int, (Int, Double))]"
          ],
          "outputTypes" : [
            "RDD[(Int, ((Int, Double), (Int, Double)))]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 26,
          "name" : "filter",
          "inputTypes" : [
            "RDD[(Int, ((Int, Double), (Int, Double)))]"
          ],
          "outputTypes" : [
            "RDD[(Int, ((Int, Double), (Int, Double)))]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 27,
          "name" : "map",
          "inputTypes" : [
            "RDD[(Int, ((Int, Double), (Int, Double)))]"
          ],
          "outputTypes" : [
            "RDD[((Int, Int), (Double, Double))]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 28,
          "name" : "groupByKey",
          "inputTypes" : [
            "RDD[((Int, Int), (Double, Double))]"
          ],
          "outputTypes" : [
            "RDD[((Int, Int), Iterable[(Double, Double)])]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 29,
          "name" : "mapValues",
          "inputTypes" : [
            "RDD[((Int, Int), Iterable[(Double, Double)])]"
          ],
          "outputTypes" : [
            "RDD[((Int, Int), (Double, Int))]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 30,
          "name" : "sortByKey",
          "inputTypes" : [
            "RDD[((Int, Int), (Double, Int))]"
          ],
          "outputTypes" : [
            "RDD[((Int, Int), (Double, Int))]"
          ],
          "loadTransformation" : false
        }
      ],
      "edges" : [
        {
          "id" : 48,
          "datasetId" : 29,
          "transformationId" : 24,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 49,
          "datasetId" : 30,
          "transformationId" : 24,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 50,
          "datasetId" : 30,
          "transformationId" : 25,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 51,
          "datasetId" : 30,
          "transformationId" : 25,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 52,
          "datasetId" : 31,
          "transformationId" : 25,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 53,
          "datasetId" : 31,
          "transformationId" : 26,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 54,
          "datasetId" : 32,
          "transformationId" : 26,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 55,
          "datasetId" : 32,
          "transformationId" : 27,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 56,
          "datasetId" : 33,
          "transformationId" : 27,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 57,
          "datasetId" : 33,
          "transformationId" : 28,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 58,
          "datasetId" : 34,
          "transformationId" : 28,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 59,
          "datasetId" : 34,
          "transformationId" : 29,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 60,
          "datasetId" : 35,
          "transformationId" : 29,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 61,
          "datasetId" : 35,
          "transformationId" : 30,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 62,
          "datasetId" : 36,
          "transformationId" : 30,
          "direction" : "TransformationToDataset"
        }
      ],
      "mutants" : [
        {
          "id" : 90,
          "originalProgramId" : 5,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 91,
          "originalProgramId" : 5,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 92,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 93,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 94,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 95,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    List[(Int, (Int, Double))]()\n  } }\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 96,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((0, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 97,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((1, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 98,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((Int.MaxValue, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 99,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((Int.MinValue, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 100,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((-originalValue._1._1, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 101,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, 0), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 102,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, 1), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 103,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, Int.MaxValue), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 104,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, Int.MinValue), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 105,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, -originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 106,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (0d, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 107,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (1d, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 108,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (Double.MaxValue, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 109,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (Double.MinValue, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 110,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (-originalValue._2._1, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 111,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, 0d))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 112,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, 1d))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 113,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, Double.MaxValue))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 114,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, Double.MinValue))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 115,
          "originalProgramId" : 5,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, -originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 116,
          "originalProgramId" : 5,
          "mutationOperator" : "FTD",
          "mutationOperatorDescription" : "Filter Transformation Deletion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 117,
          "originalProgramId" : 5,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings).distinct()\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 118,
          "originalProgramId" : 5,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings).distinct()\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 119,
          "originalProgramId" : 5,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates).distinct()\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 120,
          "originalProgramId" : 5,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs).distinct()\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 121,
          "originalProgramId" : 5,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey().distinct()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 122,
          "originalProgramId" : 5,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity).distinct()\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 123,
          "originalProgramId" : 5,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey().distinct()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 124,
          "originalProgramId" : 5,
          "mutationOperator" : "JTR",
          "mutationOperatorDescription" : "Join Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.leftOuterJoin(ratings).map(tuple => (tuple._1, (tuple._2._1, tuple._2._2.getOrElse((0, 0d)))))\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 125,
          "originalProgramId" : 5,
          "mutationOperator" : "JTR",
          "mutationOperatorDescription" : "Join Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.rightOuterJoin(ratings).map(tuple => (tuple._1, (tuple._2._1.getOrElse((0, 0d)), tuple._2._2)))\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 126,
          "originalProgramId" : 5,
          "mutationOperator" : "JTR",
          "mutationOperatorDescription" : "Join Transformation Replacement",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.fullOuterJoin(ratings).map(tuple => (tuple._1, (tuple._2._1.getOrElse((0, 0d)), tuple._2._2.getOrElse((0, 0d)))))\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 127,
          "originalProgramId" : 5,
          "mutationOperator" : "OTD",
          "mutationOperatorDescription" : "Order Transformation Deletion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 128,
          "originalProgramId" : 5,
          "mutationOperator" : "NFTP",
          "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = removeDuplicates(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        },
        {
          "id" : 129,
          "originalProgramId" : 5,
          "mutationOperator" : "OTI",
          "mutationOperatorDescription" : "Order Transformation Inversion",
          "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey(false)\n  sortedMoviesSimilarities\n}",
          "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
          "status" : "Killed"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 3,
          "UTR" : 0,
          "MTR" : 24,
          "UTD" : 2,
          "OTD" : 1,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 1,
          "DTI" : 7,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 22,
          "UTD" : 2,
          "OTD" : 1,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 1,
          "DTI" : 2,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 3,
          "UTR" : 0,
          "MTR" : 2,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 5,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalDatasets" : 8,
      "totalTransformations" : 7,
      "totalMutants" : 40,
      "totalKilledMutants" : 30,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 10,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 6,
      "programSourceId" : 5,
      "name" : "topNMoviesRecommendation",
      "code" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "datasets" : [
        {
          "id" : 37,
          "name" : "sortedMoviesSimilarities",
          "datasetType" : "RDD[((Int, Int), (Double, Int))]",
          "inputDataset" : true,
          "outputDataset" : false
        },
        {
          "id" : 38,
          "name" : "relevantMoviesSimilarities",
          "datasetType" : "RDD[((Int, Int), (Double, Int))]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 39,
          "name" : "recommendedMoviesPairs",
          "datasetType" : "RDD[(Int, (Int, Double))]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 40,
          "name" : "recommendedMoviesList",
          "datasetType" : "RDD[(Int, Iterable[(Int, Double)])]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 41,
          "name" : "sortedRecommendedMoviesList",
          "datasetType" : "RDD[(Int, Iterable[(Int, Double)])]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 42,
          "name" : "topNRecommendedMoviesByMovie",
          "datasetType" : "RDD[String]",
          "inputDataset" : false,
          "outputDataset" : true
        }
      ],
      "transformations" : [
        {
          "id" : 31,
          "name" : "filter",
          "inputTypes" : [
            "RDD[((Int, Int), (Double, Int))]"
          ],
          "outputTypes" : [
            "RDD[((Int, Int), (Double, Int))]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 32,
          "name" : "flatMap",
          "inputTypes" : [
            "RDD[((Int, Int), (Double, Int))]"
          ],
          "outputTypes" : [
            "RDD[(Int, (Int, Double))]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 33,
          "name" : "groupByKey",
          "inputTypes" : [
            "RDD[(Int, (Int, Double))]"
          ],
          "outputTypes" : [
            "RDD[(Int, Iterable[(Int, Double)])]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 34,
          "name" : "sortByKey",
          "inputTypes" : [
            "RDD[(Int, Iterable[(Int, Double)])]"
          ],
          "outputTypes" : [
            "RDD[(Int, Iterable[(Int, Double)])]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 35,
          "name" : "map",
          "inputTypes" : [
            "RDD[(Int, Iterable[(Int, Double)])]"
          ],
          "outputTypes" : [
            "RDD[String]"
          ],
          "loadTransformation" : false
        }
      ],
      "edges" : [
        {
          "id" : 63,
          "datasetId" : 37,
          "transformationId" : 31,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 64,
          "datasetId" : 38,
          "transformationId" : 31,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 65,
          "datasetId" : 38,
          "transformationId" : 32,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 66,
          "datasetId" : 39,
          "transformationId" : 32,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 67,
          "datasetId" : 39,
          "transformationId" : 33,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 68,
          "datasetId" : 40,
          "transformationId" : 33,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 69,
          "datasetId" : 40,
          "transformationId" : 34,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 70,
          "datasetId" : 41,
          "transformationId" : 34,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 71,
          "datasetId" : 41,
          "transformationId" : 35,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 72,
          "datasetId" : 42,
          "transformationId" : 35,
          "direction" : "TransformationToDataset"
        }
      ],
      "mutants" : [
        {
          "id" : 130,
          "originalProgramId" : 6,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 131,
          "originalProgramId" : 6,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 132,
          "originalProgramId" : 6,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = makeMoviesSimilaritiesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 133,
          "originalProgramId" : 6,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = makeMoviesSimilaritiesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 134,
          "originalProgramId" : 6,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = makeMoviesSimilaritiesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 135,
          "originalProgramId" : 6,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = makeMoviesSimilaritiesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    List[(Int, (Int, Double))]()\n  } }\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 136,
          "originalProgramId" : 6,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (inputParameter: (Int, Iterable[(Int, Double)])) => {\n    val originalFunction = ((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))(_)\n    val originalValue = originalFunction(inputParameter)\n    \"\"\n  } }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 137,
          "originalProgramId" : 6,
          "mutationOperator" : "FTD",
          "mutationOperatorDescription" : "Filter Transformation Deletion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 138,
          "originalProgramId" : 6,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }.distinct()\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 139,
          "originalProgramId" : 6,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs).distinct()\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 140,
          "originalProgramId" : 6,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey().distinct()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 141,
          "originalProgramId" : 6,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey().distinct()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 142,
          "originalProgramId" : 6,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }.distinct()\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 143,
          "originalProgramId" : 6,
          "mutationOperator" : "OTD",
          "mutationOperatorDescription" : "Order Transformation Deletion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 144,
          "originalProgramId" : 6,
          "mutationOperator" : "NFTP",
          "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = ((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        },
        {
          "id" : 145,
          "originalProgramId" : 6,
          "mutationOperator" : "OTI",
          "mutationOperatorDescription" : "Order Transformation Inversion",
          "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey(false)\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
          "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
          "status" : "Killed"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 5,
          "UTD" : 2,
          "OTD" : 1,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 1,
          "DTI" : 5,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 4,
          "UTD" : 2,
          "OTD" : 1,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 1,
          "DTI" : 1,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 1,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 4,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalDatasets" : 6,
      "totalTransformations" : 5,
      "totalMutants" : 16,
      "totalKilledMutants" : 11,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 5,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 7,
      "programSourceId" : 6,
      "name" : "sameHostProblem",
      "code" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "datasets" : [
        {
          "id" : 43,
          "name" : "firstLogs",
          "datasetType" : "RDD[String]",
          "inputDataset" : true,
          "outputDataset" : false
        },
        {
          "id" : 44,
          "name" : "secondLogs",
          "datasetType" : "RDD[String]",
          "inputDataset" : true,
          "outputDataset" : false
        },
        {
          "id" : 45,
          "name" : "firstHosts",
          "datasetType" : "RDD[String]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 46,
          "name" : "secondHosts",
          "datasetType" : "RDD[String]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 47,
          "name" : "intersection",
          "datasetType" : "RDD[String]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 48,
          "name" : "cleanedHostIntersection",
          "datasetType" : "RDD[String]",
          "inputDataset" : false,
          "outputDataset" : true
        }
      ],
      "transformations" : [
        {
          "id" : 36,
          "name" : "map",
          "inputTypes" : [
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[String]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 37,
          "name" : "map",
          "inputTypes" : [
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[String]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 38,
          "name" : "intersection",
          "inputTypes" : [
            "RDD[String]",
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[String]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 39,
          "name" : "filter",
          "inputTypes" : [
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[String]"
          ],
          "loadTransformation" : false
        }
      ],
      "edges" : [
        {
          "id" : 73,
          "datasetId" : 43,
          "transformationId" : 36,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 74,
          "datasetId" : 45,
          "transformationId" : 36,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 75,
          "datasetId" : 44,
          "transformationId" : 37,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 76,
          "datasetId" : 46,
          "transformationId" : 37,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 77,
          "datasetId" : 45,
          "transformationId" : 38,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 78,
          "datasetId" : 46,
          "transformationId" : 38,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 79,
          "datasetId" : 47,
          "transformationId" : 38,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 80,
          "datasetId" : 47,
          "transformationId" : 39,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 81,
          "datasetId" : 48,
          "transformationId" : 39,
          "direction" : "TransformationToDataset"
        }
      ],
      "mutants" : [
        {
          "id" : 146,
          "originalProgramId" : 7,
          "mutationOperator" : "UTS",
          "mutationOperatorDescription" : "Unary Transformation Swap",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 147,
          "originalProgramId" : 7,
          "mutationOperator" : "UTS",
          "mutationOperatorDescription" : "Unary Transformation Swap",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.filter(host => isNotHeaderHost(host))\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.map(parseLogs)\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 148,
          "originalProgramId" : 7,
          "mutationOperator" : "UTS",
          "mutationOperatorDescription" : "Unary Transformation Swap",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.filter(host => isNotHeaderHost(host))\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.map(parseLogs)\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 149,
          "originalProgramId" : 7,
          "mutationOperator" : "UTR",
          "mutationOperatorDescription" : "Unary Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 150,
          "originalProgramId" : 7,
          "mutationOperator" : "UTR",
          "mutationOperatorDescription" : "Unary Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.filter(host => isNotHeaderHost(host))\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 151,
          "originalProgramId" : 7,
          "mutationOperator" : "UTR",
          "mutationOperatorDescription" : "Unary Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 152,
          "originalProgramId" : 7,
          "mutationOperator" : "UTR",
          "mutationOperatorDescription" : "Unary Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.filter(host => isNotHeaderHost(host))\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 153,
          "originalProgramId" : 7,
          "mutationOperator" : "UTR",
          "mutationOperatorDescription" : "Unary Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.map(parseLogs)\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 154,
          "originalProgramId" : 7,
          "mutationOperator" : "UTR",
          "mutationOperatorDescription" : "Unary Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.map(parseLogs)\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 155,
          "originalProgramId" : 7,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 156,
          "originalProgramId" : 7,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 157,
          "originalProgramId" : 7,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 158,
          "originalProgramId" : 7,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map { (inputParameter: String) => {\n    val originalFunction = parseLogs(_)\n    val originalValue = originalFunction(inputParameter)\n    \"\"\n  } }\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 159,
          "originalProgramId" : 7,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map { (inputParameter: String) => {\n    val originalFunction = parseLogs(_)\n    val originalValue = originalFunction(inputParameter)\n    \"\"\n  } }\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 160,
          "originalProgramId" : 7,
          "mutationOperator" : "FTD",
          "mutationOperatorDescription" : "Filter Transformation Deletion",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 161,
          "originalProgramId" : 7,
          "mutationOperator" : "STR",
          "mutationOperatorDescription" : "Set Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.union(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 162,
          "originalProgramId" : 7,
          "mutationOperator" : "STR",
          "mutationOperatorDescription" : "Set Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.subtract(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 163,
          "originalProgramId" : 7,
          "mutationOperator" : "STR",
          "mutationOperatorDescription" : "Set Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 164,
          "originalProgramId" : 7,
          "mutationOperator" : "STR",
          "mutationOperatorDescription" : "Set Transformation Replacement",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = secondHosts\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        },
        {
          "id" : 165,
          "originalProgramId" : 7,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs).distinct()\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 166,
          "originalProgramId" : 7,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs).distinct()\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 167,
          "originalProgramId" : 7,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts).distinct()\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 168,
          "originalProgramId" : 7,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host)).distinct()\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 169,
          "originalProgramId" : 7,
          "mutationOperator" : "NFTP",
          "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
          "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter { (inputParameter: String) => {\n    val originalFunction = (host => isNotHeaderHost(host))(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  cleanedHostIntersection\n}",
          "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
          "status" : "Killed"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 0,
          "UTR" : 6,
          "MTR" : 2,
          "UTD" : 3,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 4,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 4,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 3
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 0,
          "UTR" : 4,
          "MTR" : 2,
          "UTD" : 3,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 4,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 2
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 2,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 4,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 1
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalDatasets" : 6,
      "totalTransformations" : 4,
      "totalMutants" : 24,
      "totalKilledMutants" : 17,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 7,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 8,
      "programSourceId" : 6,
      "name" : "unionLogsProblem",
      "code" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
      "datasets" : [
        {
          "id" : 49,
          "name" : "firstLogs",
          "datasetType" : "RDD[String]",
          "inputDataset" : true,
          "outputDataset" : false
        },
        {
          "id" : 50,
          "name" : "secondLogs",
          "datasetType" : "RDD[String]",
          "inputDataset" : true,
          "outputDataset" : false
        },
        {
          "id" : 51,
          "name" : "aggregatedLogLines",
          "datasetType" : "RDD[String]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 52,
          "name" : "uniqueLogLines",
          "datasetType" : "RDD[String]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 53,
          "name" : "cleanLogLines",
          "datasetType" : "RDD[String]",
          "inputDataset" : false,
          "outputDataset" : true
        }
      ],
      "transformations" : [
        {
          "id" : 40,
          "name" : "union",
          "inputTypes" : [
            "RDD[String]",
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[String]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 41,
          "name" : "distinct",
          "inputTypes" : [
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[String]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 42,
          "name" : "filter",
          "inputTypes" : [
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[String]"
          ],
          "loadTransformation" : false
        }
      ],
      "edges" : [
        {
          "id" : 82,
          "datasetId" : 49,
          "transformationId" : 40,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 83,
          "datasetId" : 50,
          "transformationId" : 40,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 84,
          "datasetId" : 51,
          "transformationId" : 40,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 85,
          "datasetId" : 51,
          "transformationId" : 41,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 86,
          "datasetId" : 52,
          "transformationId" : 41,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 87,
          "datasetId" : 52,
          "transformationId" : 42,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 88,
          "datasetId" : 53,
          "transformationId" : 42,
          "direction" : "TransformationToDataset"
        }
      ],
      "mutants" : [
        {
          "id" : 170,
          "originalProgramId" : 8,
          "mutationOperator" : "UTS",
          "mutationOperatorDescription" : "Unary Transformation Swap",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.filter(line => isNotHeader(line))\n  val cleanLogLines: RDD[String] = uniqueLogLines.distinct()\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 171,
          "originalProgramId" : 8,
          "mutationOperator" : "UTR",
          "mutationOperatorDescription" : "Unary Transformation Replacement",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.filter(line => isNotHeader(line))\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 172,
          "originalProgramId" : 8,
          "mutationOperator" : "UTR",
          "mutationOperatorDescription" : "Unary Transformation Replacement",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.distinct()\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 173,
          "originalProgramId" : 8,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 174,
          "originalProgramId" : 8,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 175,
          "originalProgramId" : 8,
          "mutationOperator" : "FTD",
          "mutationOperatorDescription" : "Filter Transformation Deletion",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 176,
          "originalProgramId" : 8,
          "mutationOperator" : "STR",
          "mutationOperatorDescription" : "Set Transformation Replacement",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.intersection(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 177,
          "originalProgramId" : 8,
          "mutationOperator" : "STR",
          "mutationOperatorDescription" : "Set Transformation Replacement",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.subtract(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 178,
          "originalProgramId" : 8,
          "mutationOperator" : "STR",
          "mutationOperatorDescription" : "Set Transformation Replacement",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 179,
          "originalProgramId" : 8,
          "mutationOperator" : "STR",
          "mutationOperatorDescription" : "Set Transformation Replacement",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = secondLogs\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 180,
          "originalProgramId" : 8,
          "mutationOperator" : "DTD",
          "mutationOperatorDescription" : "Distinct Transformation Deletion",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        },
        {
          "id" : 181,
          "originalProgramId" : 8,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs).distinct()\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 182,
          "originalProgramId" : 8,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line)).distinct()\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 183,
          "originalProgramId" : 8,
          "mutationOperator" : "NFTP",
          "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
          "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter { (inputParameter: String) => {\n    val originalFunction = (line => isNotHeader(line))(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  cleanLogLines\n}",
          "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
          "status" : "Killed"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 0,
          "UTR" : 2,
          "MTR" : 0,
          "UTD" : 2,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 4,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 2,
          "DTD" : 1,
          "NFTP" : 1,
          "UTS" : 1
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 0,
          "UTR" : 2,
          "MTR" : 0,
          "UTD" : 2,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 4,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 1,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 2,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 1
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalDatasets" : 5,
      "totalTransformations" : 3,
      "totalMutants" : 14,
      "totalKilledMutants" : 11,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 3,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 9,
      "programSourceId" : 7,
      "name" : "countNGrams",
      "code" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "datasets" : [
        {
          "id" : 54,
          "name" : "input",
          "datasetType" : "RDD[String]",
          "inputDataset" : true,
          "outputDataset" : false
        },
        {
          "id" : 55,
          "name" : "sentences",
          "datasetType" : "RDD[String]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 56,
          "name" : "ngrams",
          "datasetType" : "RDD[List[String]]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 57,
          "name" : "ngramsFiltered",
          "datasetType" : "RDD[List[String]]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 58,
          "name" : "ngramsPairs",
          "datasetType" : "RDD[(List[String], Int)]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 59,
          "name" : "ngramsCount",
          "datasetType" : "RDD[(List[String], Int)]",
          "inputDataset" : false,
          "outputDataset" : true
        }
      ],
      "transformations" : [
        {
          "id" : 43,
          "name" : "flatMap",
          "inputTypes" : [
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[String]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 44,
          "name" : "flatMap",
          "inputTypes" : [
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[List[String]]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 45,
          "name" : "filter",
          "inputTypes" : [
            "RDD[List[String]]"
          ],
          "outputTypes" : [
            "RDD[List[String]]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 46,
          "name" : "map",
          "inputTypes" : [
            "RDD[List[String]]"
          ],
          "outputTypes" : [
            "RDD[(List[String], Int)]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 47,
          "name" : "reduceByKey",
          "inputTypes" : [
            "RDD[(List[String], Int)]"
          ],
          "outputTypes" : [
            "RDD[(List[String], Int)]"
          ],
          "loadTransformation" : false
        }
      ],
      "edges" : [
        {
          "id" : 89,
          "datasetId" : 54,
          "transformationId" : 43,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 90,
          "datasetId" : 55,
          "transformationId" : 43,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 91,
          "datasetId" : 55,
          "transformationId" : 44,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 92,
          "datasetId" : 56,
          "transformationId" : 44,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 93,
          "datasetId" : 56,
          "transformationId" : 45,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 94,
          "datasetId" : 57,
          "transformationId" : 45,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 95,
          "datasetId" : 57,
          "transformationId" : 46,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 96,
          "datasetId" : 58,
          "transformationId" : 46,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 97,
          "datasetId" : 58,
          "transformationId" : 47,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 98,
          "datasetId" : 59,
          "transformationId" : 47,
          "direction" : "TransformationToDataset"
        }
      ],
      "mutants" : [
        {
          "id" : 184,
          "originalProgramId" : 9,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 185,
          "originalProgramId" : 9,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 186,
          "originalProgramId" : 9,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 187,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap { (inputParameter: String) => {\n    val originalFunction = tokenize(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 188,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap { (inputParameter: String) => {\n    val originalFunction = tokenize(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 189,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap { (inputParameter: String) => {\n    val originalFunction = tokenize(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 190,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap { (inputParameter: String) => {\n    val originalFunction = tokenize(_)\n    val originalValue = originalFunction(inputParameter)\n    List[String]()\n  } }\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 191,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (inputParameter: String) => {\n    val originalFunction = ((s: String) => nGrams(s))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 192,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (inputParameter: String) => {\n    val originalFunction = ((s: String) => nGrams(s))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 193,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (inputParameter: String) => {\n    val originalFunction = ((s: String) => nGrams(s))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 194,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (inputParameter: String) => {\n    val originalFunction = ((s: String) => nGrams(s))(_)\n    val originalValue = originalFunction(inputParameter)\n    List[List[String]]()\n  } }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 195,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (List[String](originalValue._1.head), originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 196,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1.tail, originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 197,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1.reverse, originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 198,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (List[String](), originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 199,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 0)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 200,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 1)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 201,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MaxValue)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 202,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MinValue)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 203,
          "originalProgramId" : 9,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, -originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 204,
          "originalProgramId" : 9,
          "mutationOperator" : "FTD",
          "mutationOperatorDescription" : "Filter Transformation Deletion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 205,
          "originalProgramId" : 9,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize).distinct()\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 206,
          "originalProgramId" : 9,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }.distinct()\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 207,
          "originalProgramId" : 9,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }.distinct()\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 208,
          "originalProgramId" : 9,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }.distinct()\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 209,
          "originalProgramId" : 9,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }.distinct()\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 210,
          "originalProgramId" : 9,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => firstParameter }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 211,
          "originalProgramId" : 9,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => secondParameter }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 212,
          "originalProgramId" : 9,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((x: Int, y: Int) => x + y)(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 213,
          "originalProgramId" : 9,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((x: Int, y: Int) => x + y)(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        },
        {
          "id" : 214,
          "originalProgramId" : 9,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((x: Int, y: Int) => x + y)(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Equivalent"
        },
        {
          "id" : 215,
          "originalProgramId" : 9,
          "mutationOperator" : "NFTP",
          "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
          "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => filterEmpty(ngram))(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
          "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
          "status" : "Killed"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 17,
          "UTD" : 3,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 5,
          "OTI" : 0,
          "DTI" : 5,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 14,
          "UTD" : 3,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 4,
          "OTI" : 0,
          "DTI" : 4,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 3,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 1,
          "OTI" : 0,
          "DTI" : 1,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalDatasets" : 6,
      "totalTransformations" : 5,
      "totalMutants" : 32,
      "totalKilledMutants" : 27,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 5,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 10,
      "programSourceId" : 8,
      "name" : "scan",
      "code" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
      "datasets" : [
        {
          "id" : 60,
          "name" : "input",
          "datasetType" : "RDD[String]",
          "inputDataset" : true,
          "outputDataset" : false
        },
        {
          "id" : 61,
          "name" : "rankings",
          "datasetType" : "RDD[Ranking]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 62,
          "name" : "filteredRankings",
          "datasetType" : "RDD[Ranking]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 63,
          "name" : "results",
          "datasetType" : "RDD[(String, Int)]",
          "inputDataset" : false,
          "outputDataset" : true
        }
      ],
      "transformations" : [
        {
          "id" : 48,
          "name" : "map",
          "inputTypes" : [
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[Ranking]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 49,
          "name" : "filter",
          "inputTypes" : [
            "RDD[Ranking]"
          ],
          "outputTypes" : [
            "RDD[Ranking]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 50,
          "name" : "map",
          "inputTypes" : [
            "RDD[Ranking]"
          ],
          "outputTypes" : [
            "RDD[(String, Int)]"
          ],
          "loadTransformation" : false
        }
      ],
      "edges" : [
        {
          "id" : 99,
          "datasetId" : 60,
          "transformationId" : 48,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 100,
          "datasetId" : 61,
          "transformationId" : 48,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 101,
          "datasetId" : 61,
          "transformationId" : 49,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 102,
          "datasetId" : 62,
          "transformationId" : 49,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 103,
          "datasetId" : 62,
          "transformationId" : 50,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 104,
          "datasetId" : 63,
          "transformationId" : 50,
          "direction" : "TransformationToDataset"
        }
      ],
      "mutants" : [
        {
          "id" : 216,
          "originalProgramId" : 10,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 217,
          "originalProgramId" : 10,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map { (inputParameter: String) => {\n    val originalFunction = parseRankings(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[Ranking]\n  } }\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 218,
          "originalProgramId" : 10,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 219,
          "originalProgramId" : 10,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 0)\n  } }\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 220,
          "originalProgramId" : 10,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 1)\n  } }\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 221,
          "originalProgramId" : 10,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MaxValue)\n  } }\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 222,
          "originalProgramId" : 10,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MinValue)\n  } }\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 223,
          "originalProgramId" : 10,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, -originalValue._2)\n  } }\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 224,
          "originalProgramId" : 10,
          "mutationOperator" : "FTD",
          "mutationOperatorDescription" : "Filter Transformation Deletion",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 225,
          "originalProgramId" : 10,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings).distinct()\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 226,
          "originalProgramId" : 10,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings).distinct()\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 227,
          "originalProgramId" : 10,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple).distinct()\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        },
        {
          "id" : 228,
          "originalProgramId" : 10,
          "mutationOperator" : "NFTP",
          "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
          "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter { (inputParameter: Ranking) => {\n    val originalFunction = filterRankings(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
          "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
          "status" : "Killed"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 7,
          "UTD" : 1,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 3,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 1,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 7,
          "UTD" : 1,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 3,
          "DTD" : 0,
          "NFTP" : 1,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalDatasets" : 4,
      "totalTransformations" : 3,
      "totalMutants" : 13,
      "totalKilledMutants" : 13,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 0,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    },
    {
      "id" : 11,
      "programSourceId" : 9,
      "name" : "wordCount",
      "code" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "datasets" : [
        {
          "id" : 64,
          "name" : "input",
          "datasetType" : "RDD[String]",
          "inputDataset" : true,
          "outputDataset" : false
        },
        {
          "id" : 65,
          "name" : "words",
          "datasetType" : "RDD[String]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 66,
          "name" : "pairs",
          "datasetType" : "RDD[(String, Int)]",
          "inputDataset" : false,
          "outputDataset" : false
        },
        {
          "id" : 67,
          "name" : "counts",
          "datasetType" : "RDD[(String, Int)]",
          "inputDataset" : false,
          "outputDataset" : true
        }
      ],
      "transformations" : [
        {
          "id" : 51,
          "name" : "flatMap",
          "inputTypes" : [
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[String]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 52,
          "name" : "map",
          "inputTypes" : [
            "RDD[String]"
          ],
          "outputTypes" : [
            "RDD[(String, Int)]"
          ],
          "loadTransformation" : false
        },
        {
          "id" : 53,
          "name" : "reduceByKey",
          "inputTypes" : [
            "RDD[(String, Int)]"
          ],
          "outputTypes" : [
            "RDD[(String, Int)]"
          ],
          "loadTransformation" : false
        }
      ],
      "edges" : [
        {
          "id" : 105,
          "datasetId" : 64,
          "transformationId" : 51,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 106,
          "datasetId" : 65,
          "transformationId" : 51,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 107,
          "datasetId" : 65,
          "transformationId" : 52,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 108,
          "datasetId" : 66,
          "transformationId" : 52,
          "direction" : "TransformationToDataset"
        },
        {
          "id" : 109,
          "datasetId" : 66,
          "transformationId" : 53,
          "direction" : "DatasetToTransformation"
        },
        {
          "id" : 110,
          "datasetId" : 67,
          "transformationId" : 53,
          "direction" : "TransformationToDataset"
        }
      ],
      "mutants" : [
        {
          "id" : 229,
          "originalProgramId" : 11,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 230,
          "originalProgramId" : 11,
          "mutationOperator" : "UTD",
          "mutationOperatorDescription" : "Unary Transformation Deletion",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 231,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (inputParameter: String) => {\n    val originalFunction = ((line: String) => line.split(\" \"))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 232,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (inputParameter: String) => {\n    val originalFunction = ((line: String) => line.split(\" \"))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 233,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (inputParameter: String) => {\n    val originalFunction = ((line: String) => line.split(\" \"))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Equivalent"
        },
        {
          "id" : 234,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (inputParameter: String) => {\n    val originalFunction = ((line: String) => line.split(\" \"))(_)\n    val originalValue = originalFunction(inputParameter)\n    List[String]()\n  } }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 235,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 236,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 0)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 237,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 1)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Equivalent"
        },
        {
          "id" : 238,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MaxValue)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 239,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MinValue)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 240,
          "originalProgramId" : 11,
          "mutationOperator" : "MTR",
          "mutationOperatorDescription" : "Mapping Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, -originalValue._2)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 241,
          "originalProgramId" : 11,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }.distinct()\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 242,
          "originalProgramId" : 11,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }.distinct()\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 243,
          "originalProgramId" : 11,
          "mutationOperator" : "DTI",
          "mutationOperatorDescription" : "Distinct Transformation Insertion",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }.distinct()\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Equivalent"
        },
        {
          "id" : 244,
          "originalProgramId" : 11,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => firstParameter }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 245,
          "originalProgramId" : 11,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => secondParameter }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 246,
          "originalProgramId" : 11,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((a: Int, b: Int) => a + b)(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 247,
          "originalProgramId" : 11,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((a: Int, b: Int) => a + b)(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Killed"
        },
        {
          "id" : 248,
          "originalProgramId" : 11,
          "mutationOperator" : "ATR",
          "mutationOperatorDescription" : "Aggregation Transformation Replacement",
          "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((a: Int, b: Int) => a + b)(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  counts\n}",
          "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
          "status" : "Equivalent"
        }
      ],
      "removedMutants" : [
      ],
      "mutationOperatorsMetrics" : {
        "totalMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 10,
          "UTD" : 2,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 5,
          "OTI" : 0,
          "DTI" : 3,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalKilledMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 8,
          "UTD" : 2,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 4,
          "OTI" : 0,
          "DTI" : 2,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalLivedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalEquivalentMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 2,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 1,
          "OTI" : 0,
          "DTI" : 1,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalErrorMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "totalRemovedMutantsPerOperator" : {
          "FTD" : 0,
          "JTR" : 0,
          "UTR" : 0,
          "MTR" : 0,
          "UTD" : 0,
          "OTD" : 0,
          "BTR" : 0,
          "STR" : 0,
          "BTS" : 0,
          "ATR" : 0,
          "OTI" : 0,
          "DTI" : 0,
          "DTD" : 0,
          "NFTP" : 0,
          "UTS" : 0
        },
        "descriptionPerOperator" : {
          "FTD" : "Filter Transformation Deletion",
          "JTR" : "Join Transformation Replacement",
          "UTR" : "Unary Transformation Replacement",
          "MTR" : "Mapping Transformation Replacement",
          "UTD" : "Unary Transformation Deletion",
          "OTD" : "Order Transformation Deletion",
          "BTR" : "Binary Transformation Replacement",
          "STR" : "Set Transformation Replacement",
          "BTS" : "Binary Transformation Swap",
          "ATR" : "Aggregation Transformation Replacement",
          "OTI" : "Order Transformation Inversion",
          "DTI" : "Distinct Transformation Insertion",
          "DTD" : "Distinct Transformation Deletion",
          "NFTP" : "Negation of Filter Transformation Predicate",
          "UTS" : "Unary Transformation Swap"
        }
      },
      "totalDatasets" : 4,
      "totalTransformations" : 3,
      "totalMutants" : 20,
      "totalKilledMutants" : 16,
      "totalLivedMutants" : 0,
      "totalEquivalentMutants" : 4,
      "totalErrorMutants" : 0,
      "totalRemovedMutants" : 0,
      "mutationScore" : 1.0
    }
  ],
  "mutants" : [
    {
      "id" : 1,
      "originalProgramId" : 1,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples\n  results\n}",
      "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 2,
      "originalProgramId" : 1,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map { (inputParameter: String) => {\n    val originalFunction = parseUserVisits(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[UserVisit]\n  } }\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
      "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 3,
      "originalProgramId" : 1,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
      "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 4,
      "originalProgramId" : 1,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 0f)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
      "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 5,
      "originalProgramId" : 1,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 1f)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
      "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 6,
      "originalProgramId" : 1,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Float.MaxValue)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
      "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 7,
      "originalProgramId" : 1,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Float.MinValue)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
      "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 8,
      "originalProgramId" : 1,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, -originalValue._2)\n  } }\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
      "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 9,
      "originalProgramId" : 1,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits).distinct()\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
      "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 10,
      "originalProgramId" : 1,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple).distinct()\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }\n  results\n}",
      "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 11,
      "originalProgramId" : 1,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (x: Float, y: Float) => x + y }.distinct()\n  results\n}",
      "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 12,
      "originalProgramId" : 1,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => firstParameter }\n  results\n}",
      "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 13,
      "originalProgramId" : 1,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => secondParameter }\n  results\n}",
      "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 14,
      "originalProgramId" : 1,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => {\n    val originalFunction = ((x: Float, y: Float) => x + y)(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  results\n}",
      "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 15,
      "originalProgramId" : 1,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => {\n    val originalFunction = ((x: Float, y: Float) => x + y)(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  results\n}",
      "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 16,
      "originalProgramId" : 1,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def aggregation(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n  val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey { (firstParameter: Float, secondParameter: Float) => {\n    val originalFunction = ((x: Float, y: Float) => x + y)(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  results\n}",
      "originalCode" : "def aggregation(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userVisitsTuples: RDD[(String, Float)] = userVisits.map(mapUserVisitToTuple)\n    val results: RDD[(String, Float)] = userVisitsTuples.reduceByKey((x: Float, y: Float) => x + y)\n    results\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 17,
      "originalProgramId" : 2,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Killed"
    },
    {
      "id" : 18,
      "originalProgramId" : 2,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map { (inputParameter: String) => {\n    val originalFunction = parseUserVisits(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[UserVisit]\n  } }\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Killed"
    },
    {
      "id" : 19,
      "originalProgramId" : 2,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Killed"
    },
    {
      "id" : 20,
      "originalProgramId" : 2,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, \"\")\n  } }\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Killed"
    },
    {
      "id" : 21,
      "originalProgramId" : 2,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map { (inputParameter: (String, String)) => {\n    val originalFunction = mapSourceIPToSet(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Killed"
    },
    {
      "id" : 22,
      "originalProgramId" : 2,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map { (inputParameter: (String, String)) => {\n    val originalFunction = mapSourceIPToSet(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Set[String](originalValue._2.head))\n  } }\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 23,
      "originalProgramId" : 2,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map { (inputParameter: (String, String)) => {\n    val originalFunction = mapSourceIPToSet(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, originalValue._2.tail)\n  } }\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Killed"
    },
    {
      "id" : 24,
      "originalProgramId" : 2,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map { (inputParameter: (String, String)) => {\n    val originalFunction = mapSourceIPToSet(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Set[String]())\n  } }\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Killed"
    },
    {
      "id" : 25,
      "originalProgramId" : 2,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits).distinct()\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 26,
      "originalProgramId" : 2,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple).distinct()\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 27,
      "originalProgramId" : 2,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet).distinct()\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 28,
      "originalProgramId" : 2,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion).distinct()\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 29,
      "originalProgramId" : 2,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => firstParameter }\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Killed"
    },
    {
      "id" : 30,
      "originalProgramId" : 2,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => secondParameter }\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Killed"
    },
    {
      "id" : 31,
      "originalProgramId" : 2,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => {\n    val originalFunction = setUnion(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Killed"
    },
    {
      "id" : 32,
      "originalProgramId" : 2,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => {\n    val originalFunction = setUnion(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Killed"
    },
    {
      "id" : 33,
      "originalProgramId" : 2,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n  val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n  val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n  val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n  val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey { (firstParameter: Set[String], secondParameter: Set[String]) => {\n    val originalFunction = setUnion(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  distinctSites\n}",
      "originalCode" : "def distinctUserVisitsPerPage(input: RDD[String]) = {\n    val userVisits: RDD[UserVisit] = input.map(parseUserVisits)\n    val userAccesses: RDD[(String, String)] = userVisits.map(mapUserVisitToTuple)\n    val mapedUserAccess: RDD[(String, Set[String])] = userAccesses.map(mapSourceIPToSet)\n    val distinctSites: RDD[(String, Set[String])] = mapedUserAccess.reduceByKey(setUnion)\n    distinctSites\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 34,
      "originalProgramId" : 3,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 35,
      "originalProgramId" : 3,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 36,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map { (inputParameter: String) => {\n    val originalFunction = parseRankings(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[Ranking]\n  } }\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 37,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map { (inputParameter: String) => {\n    val originalFunction = parseUserVisits(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[UserVisit]\n  } }\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 38,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 39,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map { (inputParameter: UserVisit) => {\n    val originalFunction = mapUserVisitToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, null.asInstanceOf[UserVisit])\n  } }\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 40,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 41,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, null.asInstanceOf[Ranking])\n  } }\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 42,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 43,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (0f, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 44,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (1f, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 45,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (Float.MaxValue, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 46,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (Float.MinValue, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 47,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (-originalValue._2._1, originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 48,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, 0))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 49,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, 1))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 50,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, Int.MaxValue))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 51,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, Int.MinValue))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 52,
      "originalProgramId" : 3,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map { (inputParameter: (Ranking, UserVisit)) => {\n    val originalFunction = mapRankingAndUserVisitJoinToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, -originalValue._2._2))\n  } }\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 53,
      "originalProgramId" : 3,
      "mutationOperator" : "FTD",
      "mutationOperatorDescription" : "Filter Transformation Deletion",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 54,
      "originalProgramId" : 3,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings).distinct()\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 55,
      "originalProgramId" : 3,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits).distinct()\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 56,
      "originalProgramId" : 3,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange).distinct()\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 57,
      "originalProgramId" : 3,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple).distinct()\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 58,
      "originalProgramId" : 3,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple).distinct()\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 59,
      "originalProgramId" : 3,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV).distinct()\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 60,
      "originalProgramId" : 3,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values.distinct()\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 61,
      "originalProgramId" : 3,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple).distinct()\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 62,
      "originalProgramId" : 3,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey().distinct()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 63,
      "originalProgramId" : 3,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation).distinct()\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 64,
      "originalProgramId" : 3,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false).distinct()\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 65,
      "originalProgramId" : 3,
      "mutationOperator" : "JTR",
      "mutationOperatorDescription" : "Join Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.leftOuterJoin(subqueryUV).map(tuple => (tuple._1, (tuple._2._1, tuple._2._2.getOrElse(null.asInstanceOf[UserVisit]))))\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 66,
      "originalProgramId" : 3,
      "mutationOperator" : "JTR",
      "mutationOperatorDescription" : "Join Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.rightOuterJoin(subqueryUV).map(tuple => (tuple._1, (tuple._2._1.getOrElse(null.asInstanceOf[Ranking]), tuple._2._2)))\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 67,
      "originalProgramId" : 3,
      "mutationOperator" : "JTR",
      "mutationOperatorDescription" : "Join Transformation Replacement",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.fullOuterJoin(subqueryUV).map(tuple => (tuple._1, (tuple._2._1.getOrElse(null.asInstanceOf[Ranking]), tuple._2._2.getOrElse(null.asInstanceOf[UserVisit]))))\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 68,
      "originalProgramId" : 3,
      "mutationOperator" : "OTD",
      "mutationOperatorDescription" : "Order Transformation Deletion",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 69,
      "originalProgramId" : 3,
      "mutationOperator" : "NFTP",
      "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter { (inputParameter: UserVisit) => {\n    val originalFunction = filterUserVisitsDateRange(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 70,
      "originalProgramId" : 3,
      "mutationOperator" : "OTI",
      "mutationOperatorDescription" : "Order Transformation Inversion",
      "mutantCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n  val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n  val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n  val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n  val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n  val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n  val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n  val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n  val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n  val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n  val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n  val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, true)\n  results\n}",
      "originalCode" : "def join(rankingsLines: RDD[String], userVisitsLines: RDD[String]): RDD[(String, Float, Int)] = {\n    val rankings: RDD[Ranking] = rankingsLines.map(parseRankings)\n    val userVisits: RDD[UserVisit] = userVisitsLines.map(parseUserVisits)\n    val filteredUV: RDD[UserVisit] = userVisits.filter(filterUserVisitsDateRange)\n    val subqueryUV: RDD[(String, UserVisit)] = filteredUV.map(mapUserVisitToTuple)\n    val subqueryR: RDD[(String, Ranking)] = rankings.map(mapRankingToTuple)\n    val subqueryJoin: RDD[(String, (Ranking, UserVisit))] = subqueryR.join(subqueryUV)\n    val subqueryJoinValues: RDD[(Ranking, UserVisit)] = subqueryJoin.values\n    val subquerySelect: RDD[(String, (Float, Int))] = subqueryJoinValues.map(mapRankingAndUserVisitJoinToTuple)\n    val subqueryGroup: RDD[(String, Iterable[(Float, Int)])] = subquerySelect.groupByKey()\n    val subqueryAggregation: RDD[(String, Float, Int)] = subqueryGroup.map(mapAggregation)\n    val results: RDD[(String, Float, Int)] = subqueryAggregation.sortBy(_._2, false)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 71,
      "originalProgramId" : 4,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Killed"
    },
    {
      "id" : 72,
      "originalProgramId" : 4,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Killed"
    },
    {
      "id" : 73,
      "originalProgramId" : 4,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 74,
      "originalProgramId" : 4,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Killed"
    },
    {
      "id" : 75,
      "originalProgramId" : 4,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 76,
      "originalProgramId" : 4,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    List[(Int, (Double, Double))]()\n  } }\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Killed"
    },
    {
      "id" : 77,
      "originalProgramId" : 4,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (inputParameter: (Int, Double)) => {\n    val originalFunction = ((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))(_)\n    val originalValue = originalFunction(inputParameter)\n    \"\"\n  } }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Killed"
    },
    {
      "id" : 78,
      "originalProgramId" : 4,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings).distinct()\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Killed"
    },
    {
      "id" : 79,
      "originalProgramId" : 4,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple).distinct()\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 80,
      "originalProgramId" : 4,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide).distinct()\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 81,
      "originalProgramId" : 4,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false).distinct()\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Killed"
    },
    {
      "id" : 82,
      "originalProgramId" : 4,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }.distinct()\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Killed"
    },
    {
      "id" : 83,
      "originalProgramId" : 4,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => firstParameter }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Killed"
    },
    {
      "id" : 84,
      "originalProgramId" : 4,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => secondParameter }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Killed"
    },
    {
      "id" : 85,
      "originalProgramId" : 4,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => {\n    val originalFunction = aggregateDoubleTuple(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Killed"
    },
    {
      "id" : 86,
      "originalProgramId" : 4,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => {\n    val originalFunction = aggregateDoubleTuple(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Killed"
    },
    {
      "id" : 87,
      "originalProgramId" : 4,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey { (firstParameter: (Double, Double), secondParameter: (Double, Double)) => {\n    val originalFunction = aggregateDoubleTuple(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 88,
      "originalProgramId" : 4,
      "mutationOperator" : "OTD",
      "mutationOperatorDescription" : "Order Transformation Deletion",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Killed"
    },
    {
      "id" : 89,
      "originalProgramId" : 4,
      "mutationOperator" : "OTI",
      "mutationOperatorDescription" : "Order Transformation Inversion",
      "mutantCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n  val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n  val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n  val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n  val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(true)\n  val resultsCVS: RDD[String] = ratingsAverageSorted.map { (x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames) }\n  resultsCVS\n}",
      "originalCode" : "def moviesRatingsAverage(inputRDD: RDD[String], movieNames: Broadcast[Map[Int, String]]) = {\n\n    val ratings: RDD[(Int, (Double, Double))] = inputRDD.flatMap(parseRatings)\n\n    val ratingsSum: RDD[(Int, (Double, Double))] = ratings.reduceByKey(aggregateDoubleTuple)\n\n    val ratingsAverage: RDD[(Int, Double)] = ratingsSum.mapValues(mapDoubleTupleDivide)\n\n    val ratingsAverageSorted: RDD[(Int, Double)] = ratingsAverage.sortByKey(false)\n\n    val resultsCVS: RDD[String] = ratingsAverageSorted.map((x: (Int, Double)) => mapRatingsAverageToCSV(x, movieNames))\n\n    resultsCVS\n  }",
      "status" : "Killed"
    },
    {
      "id" : 90,
      "originalProgramId" : 5,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 91,
      "originalProgramId" : 5,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 92,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 93,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 94,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 95,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap { (inputParameter: String) => {\n    val originalFunction = parseRatings(_)\n    val originalValue = originalFunction(inputParameter)\n    List[(Int, (Int, Double))]()\n  } }\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 96,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((0, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 97,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((1, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 98,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((Int.MaxValue, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 99,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((Int.MinValue, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 100,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((-originalValue._1._1, originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 101,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, 0), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 102,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, 1), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 103,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, Int.MaxValue), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 104,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, Int.MinValue), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 105,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    ((originalValue._1._1, -originalValue._1._2), originalValue._2)\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 106,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (0d, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 107,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (1d, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 108,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (Double.MaxValue, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 109,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (Double.MinValue, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 110,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (-originalValue._2._1, originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 111,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, 0d))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 112,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, 1d))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 113,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, Double.MaxValue))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 114,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, Double.MinValue))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 115,
      "originalProgramId" : 5,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = makeCorrelatedMoviesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, (originalValue._2._1, -originalValue._2._2))\n  } }\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 116,
      "originalProgramId" : 5,
      "mutationOperator" : "FTD",
      "mutationOperatorDescription" : "Filter Transformation Deletion",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 117,
      "originalProgramId" : 5,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings).distinct()\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 118,
      "originalProgramId" : 5,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings).distinct()\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 119,
      "originalProgramId" : 5,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates).distinct()\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 120,
      "originalProgramId" : 5,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs).distinct()\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 121,
      "originalProgramId" : 5,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey().distinct()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 122,
      "originalProgramId" : 5,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity).distinct()\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 123,
      "originalProgramId" : 5,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey().distinct()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 124,
      "originalProgramId" : 5,
      "mutationOperator" : "JTR",
      "mutationOperatorDescription" : "Join Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.leftOuterJoin(ratings).map(tuple => (tuple._1, (tuple._2._1, tuple._2._2.getOrElse((0, 0d)))))\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 125,
      "originalProgramId" : 5,
      "mutationOperator" : "JTR",
      "mutationOperatorDescription" : "Join Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.rightOuterJoin(ratings).map(tuple => (tuple._1, (tuple._2._1.getOrElse((0, 0d)), tuple._2._2)))\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 126,
      "originalProgramId" : 5,
      "mutationOperator" : "JTR",
      "mutationOperatorDescription" : "Join Transformation Replacement",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.fullOuterJoin(ratings).map(tuple => (tuple._1, (tuple._2._1.getOrElse((0, 0d)), tuple._2._2.getOrElse((0, 0d)))))\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 127,
      "originalProgramId" : 5,
      "mutationOperator" : "OTD",
      "mutationOperatorDescription" : "Order Transformation Deletion",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 128,
      "originalProgramId" : 5,
      "mutationOperator" : "NFTP",
      "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter { (inputParameter: (Int, ((Int, Double), (Int, Double)))) => {\n    val originalFunction = removeDuplicates(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 129,
      "originalProgramId" : 5,
      "mutationOperator" : "OTI",
      "mutationOperatorDescription" : "Order Transformation Inversion",
      "mutantCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n  val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n  val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n  val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n  val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n  val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n  val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n  val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey(false)\n  sortedMoviesSimilarities\n}",
      "originalCode" : "def moviesSimilaritiesTable(inputRDD: RDD[String]): RDD[((Int, Int), (Double, Int))] = {\n\n    val ratings: RDD[(Int, (Int, Double))] = inputRDD.flatMap(parseRatings)\n\n    val selfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = ratings.join(ratings)\n\n    val filteredSelfJoinRatings: RDD[(Int, ((Int, Double), (Int, Double)))] = selfJoinRatings.filter(removeDuplicates)\n\n    val correlatedMovies: RDD[((Int, Int), (Double, Double))] = filteredSelfJoinRatings.map(makeCorrelatedMoviesPairs)\n\n    val correlatedMoviesGroupedRatings: RDD[((Int, Int), Iterable[(Double, Double)])] = correlatedMovies.groupByKey()\n\n    val moviesSimilarities: RDD[((Int, Int), (Double, Int))] = correlatedMoviesGroupedRatings.mapValues(similarity)\n\n    val sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = moviesSimilarities.sortByKey()\n\n    sortedMoviesSimilarities\n  }",
      "status" : "Killed"
    },
    {
      "id" : 130,
      "originalProgramId" : 6,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
      "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "status" : "Killed"
    },
    {
      "id" : 131,
      "originalProgramId" : 6,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
      "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "status" : "Killed"
    },
    {
      "id" : 132,
      "originalProgramId" : 6,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = makeMoviesSimilaritiesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
      "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "status" : "Killed"
    },
    {
      "id" : 133,
      "originalProgramId" : 6,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = makeMoviesSimilaritiesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
      "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "status" : "Killed"
    },
    {
      "id" : 134,
      "originalProgramId" : 6,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = makeMoviesSimilaritiesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
      "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 135,
      "originalProgramId" : 6,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = makeMoviesSimilaritiesPairs(_)\n    val originalValue = originalFunction(inputParameter)\n    List[(Int, (Int, Double))]()\n  } }\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
      "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "status" : "Killed"
    },
    {
      "id" : 136,
      "originalProgramId" : 6,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (inputParameter: (Int, Iterable[(Int, Double)])) => {\n    val originalFunction = ((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))(_)\n    val originalValue = originalFunction(inputParameter)\n    \"\"\n  } }\n  topNRecommendedMoviesByMovie\n}",
      "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "status" : "Killed"
    },
    {
      "id" : 137,
      "originalProgramId" : 6,
      "mutationOperator" : "FTD",
      "mutationOperatorDescription" : "Filter Transformation Deletion",
      "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
      "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "status" : "Killed"
    },
    {
      "id" : 138,
      "originalProgramId" : 6,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }.distinct()\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
      "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 139,
      "originalProgramId" : 6,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs).distinct()\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
      "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 140,
      "originalProgramId" : 6,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey().distinct()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
      "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 141,
      "originalProgramId" : 6,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey().distinct()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
      "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "status" : "Killed"
    },
    {
      "id" : 142,
      "originalProgramId" : 6,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }.distinct()\n  topNRecommendedMoviesByMovie\n}",
      "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 143,
      "originalProgramId" : 6,
      "mutationOperator" : "OTD",
      "mutationOperatorDescription" : "Order Transformation Deletion",
      "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
      "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "status" : "Killed"
    },
    {
      "id" : 144,
      "originalProgramId" : 6,
      "mutationOperator" : "NFTP",
      "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
      "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (inputParameter: ((Int, Int), (Double, Int))) => {\n    val originalFunction = ((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
      "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "status" : "Killed"
    },
    {
      "id" : 145,
      "originalProgramId" : 6,
      "mutationOperator" : "OTI",
      "mutationOperatorDescription" : "Order Transformation Inversion",
      "mutantCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n  val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter { (x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs) }\n  val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n  val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n  val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey(false)\n  val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map { (x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n) }\n  topNRecommendedMoviesByMovie\n}",
      "originalCode" : "def topNMoviesRecommendation(sortedMoviesSimilarities: RDD[((Int, Int), (Double, Int))], n: Int, minimumSimilarity: Double, minimumPairs: Int): RDD[String] = {\n\n    val relevantMoviesSimilarities: RDD[((Int, Int), (Double, Int))] = sortedMoviesSimilarities.filter((x: ((Int, Int), (Double, Int))) => relevantSimilarities(x, minimumSimilarity, minimumPairs))\n\n    val recommendedMoviesPairs: RDD[(Int, (Int, Double))] = relevantMoviesSimilarities.flatMap(makeMoviesSimilaritiesPairs)\n\n    val recommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesPairs.groupByKey()\n\n    val sortedRecommendedMoviesList: RDD[(Int, Iterable[(Int, Double)])] = recommendedMoviesList.sortByKey()\n\n    val topNRecommendedMoviesByMovie: RDD[String] = sortedRecommendedMoviesList.map((x: (Int, Iterable[(Int, Double)])) => makeTopNRecommendedMoviesCSV(x, n))\n    topNRecommendedMoviesByMovie\n  }",
      "status" : "Killed"
    },
    {
      "id" : 146,
      "originalProgramId" : 7,
      "mutationOperator" : "UTS",
      "mutationOperatorDescription" : "Unary Transformation Swap",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 147,
      "originalProgramId" : 7,
      "mutationOperator" : "UTS",
      "mutationOperatorDescription" : "Unary Transformation Swap",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.filter(host => isNotHeaderHost(host))\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.map(parseLogs)\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 148,
      "originalProgramId" : 7,
      "mutationOperator" : "UTS",
      "mutationOperatorDescription" : "Unary Transformation Swap",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.filter(host => isNotHeaderHost(host))\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.map(parseLogs)\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 149,
      "originalProgramId" : 7,
      "mutationOperator" : "UTR",
      "mutationOperatorDescription" : "Unary Transformation Replacement",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 150,
      "originalProgramId" : 7,
      "mutationOperator" : "UTR",
      "mutationOperatorDescription" : "Unary Transformation Replacement",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.filter(host => isNotHeaderHost(host))\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 151,
      "originalProgramId" : 7,
      "mutationOperator" : "UTR",
      "mutationOperatorDescription" : "Unary Transformation Replacement",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 152,
      "originalProgramId" : 7,
      "mutationOperator" : "UTR",
      "mutationOperatorDescription" : "Unary Transformation Replacement",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.filter(host => isNotHeaderHost(host))\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 153,
      "originalProgramId" : 7,
      "mutationOperator" : "UTR",
      "mutationOperatorDescription" : "Unary Transformation Replacement",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.map(parseLogs)\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 154,
      "originalProgramId" : 7,
      "mutationOperator" : "UTR",
      "mutationOperatorDescription" : "Unary Transformation Replacement",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.map(parseLogs)\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 155,
      "originalProgramId" : 7,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 156,
      "originalProgramId" : 7,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 157,
      "originalProgramId" : 7,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 158,
      "originalProgramId" : 7,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map { (inputParameter: String) => {\n    val originalFunction = parseLogs(_)\n    val originalValue = originalFunction(inputParameter)\n    \"\"\n  } }\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 159,
      "originalProgramId" : 7,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map { (inputParameter: String) => {\n    val originalFunction = parseLogs(_)\n    val originalValue = originalFunction(inputParameter)\n    \"\"\n  } }\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 160,
      "originalProgramId" : 7,
      "mutationOperator" : "FTD",
      "mutationOperatorDescription" : "Filter Transformation Deletion",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 161,
      "originalProgramId" : 7,
      "mutationOperator" : "STR",
      "mutationOperatorDescription" : "Set Transformation Replacement",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.union(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 162,
      "originalProgramId" : 7,
      "mutationOperator" : "STR",
      "mutationOperatorDescription" : "Set Transformation Replacement",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.subtract(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 163,
      "originalProgramId" : 7,
      "mutationOperator" : "STR",
      "mutationOperatorDescription" : "Set Transformation Replacement",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 164,
      "originalProgramId" : 7,
      "mutationOperator" : "STR",
      "mutationOperatorDescription" : "Set Transformation Replacement",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = secondHosts\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 165,
      "originalProgramId" : 7,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs).distinct()\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 166,
      "originalProgramId" : 7,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs).distinct()\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 167,
      "originalProgramId" : 7,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts).distinct()\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 168,
      "originalProgramId" : 7,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host)).distinct()\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 169,
      "originalProgramId" : 7,
      "mutationOperator" : "NFTP",
      "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
      "mutantCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n  val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n  val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n  val cleanedHostIntersection: RDD[String] = intersection.filter { (inputParameter: String) => {\n    val originalFunction = (host => isNotHeaderHost(host))(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  cleanedHostIntersection\n}",
      "originalCode" : "def sameHostProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val firstHosts: RDD[String] = firstLogs.map(parseLogs)\n    val secondHosts: RDD[String] = secondLogs.map(parseLogs)\n    val intersection: RDD[String] = firstHosts.intersection(secondHosts)\n    val cleanedHostIntersection: RDD[String] = intersection.filter(host => isNotHeaderHost(host))\n    cleanedHostIntersection\n  }",
      "status" : "Killed"
    },
    {
      "id" : 170,
      "originalProgramId" : 8,
      "mutationOperator" : "UTS",
      "mutationOperatorDescription" : "Unary Transformation Swap",
      "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.filter(line => isNotHeader(line))\n  val cleanLogLines: RDD[String] = uniqueLogLines.distinct()\n  cleanLogLines\n}",
      "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 171,
      "originalProgramId" : 8,
      "mutationOperator" : "UTR",
      "mutationOperatorDescription" : "Unary Transformation Replacement",
      "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.filter(line => isNotHeader(line))\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
      "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
      "status" : "Killed"
    },
    {
      "id" : 172,
      "originalProgramId" : 8,
      "mutationOperator" : "UTR",
      "mutationOperatorDescription" : "Unary Transformation Replacement",
      "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.distinct()\n  cleanLogLines\n}",
      "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
      "status" : "Killed"
    },
    {
      "id" : 173,
      "originalProgramId" : 8,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
      "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
      "status" : "Killed"
    },
    {
      "id" : 174,
      "originalProgramId" : 8,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines\n  cleanLogLines\n}",
      "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
      "status" : "Killed"
    },
    {
      "id" : 175,
      "originalProgramId" : 8,
      "mutationOperator" : "FTD",
      "mutationOperatorDescription" : "Filter Transformation Deletion",
      "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines\n  cleanLogLines\n}",
      "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
      "status" : "Killed"
    },
    {
      "id" : 176,
      "originalProgramId" : 8,
      "mutationOperator" : "STR",
      "mutationOperatorDescription" : "Set Transformation Replacement",
      "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.intersection(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
      "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
      "status" : "Killed"
    },
    {
      "id" : 177,
      "originalProgramId" : 8,
      "mutationOperator" : "STR",
      "mutationOperatorDescription" : "Set Transformation Replacement",
      "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.subtract(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
      "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
      "status" : "Killed"
    },
    {
      "id" : 178,
      "originalProgramId" : 8,
      "mutationOperator" : "STR",
      "mutationOperatorDescription" : "Set Transformation Replacement",
      "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
      "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
      "status" : "Killed"
    },
    {
      "id" : 179,
      "originalProgramId" : 8,
      "mutationOperator" : "STR",
      "mutationOperatorDescription" : "Set Transformation Replacement",
      "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = secondLogs\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
      "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
      "status" : "Killed"
    },
    {
      "id" : 180,
      "originalProgramId" : 8,
      "mutationOperator" : "DTD",
      "mutationOperatorDescription" : "Distinct Transformation Deletion",
      "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
      "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
      "status" : "Killed"
    },
    {
      "id" : 181,
      "originalProgramId" : 8,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs).distinct()\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n  cleanLogLines\n}",
      "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 182,
      "originalProgramId" : 8,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line)).distinct()\n  cleanLogLines\n}",
      "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 183,
      "originalProgramId" : 8,
      "mutationOperator" : "NFTP",
      "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
      "mutantCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n  val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n  val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n  val cleanLogLines: RDD[String] = uniqueLogLines.filter { (inputParameter: String) => {\n    val originalFunction = (line => isNotHeader(line))(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  cleanLogLines\n}",
      "originalCode" : "def unionLogsProblem(firstLogs: RDD[String], secondLogs: RDD[String]): RDD[String] = {\n    val aggregatedLogLines: RDD[String] = firstLogs.union(secondLogs)\n    val uniqueLogLines: RDD[String] = aggregatedLogLines.distinct()\n    val cleanLogLines: RDD[String] = uniqueLogLines.filter(line => isNotHeader(line))\n    cleanLogLines\n  }",
      "status" : "Killed"
    },
    {
      "id" : 184,
      "originalProgramId" : 9,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 185,
      "originalProgramId" : 9,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 186,
      "originalProgramId" : 9,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 187,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap { (inputParameter: String) => {\n    val originalFunction = tokenize(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 188,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap { (inputParameter: String) => {\n    val originalFunction = tokenize(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 189,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap { (inputParameter: String) => {\n    val originalFunction = tokenize(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 190,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap { (inputParameter: String) => {\n    val originalFunction = tokenize(_)\n    val originalValue = originalFunction(inputParameter)\n    List[String]()\n  } }\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 191,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (inputParameter: String) => {\n    val originalFunction = ((s: String) => nGrams(s))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 192,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (inputParameter: String) => {\n    val originalFunction = ((s: String) => nGrams(s))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 193,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (inputParameter: String) => {\n    val originalFunction = ((s: String) => nGrams(s))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 194,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (inputParameter: String) => {\n    val originalFunction = ((s: String) => nGrams(s))(_)\n    val originalValue = originalFunction(inputParameter)\n    List[List[String]]()\n  } }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 195,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (List[String](originalValue._1.head), originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 196,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1.tail, originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 197,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1.reverse, originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 198,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (List[String](), originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 199,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 0)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 200,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 1)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 201,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MaxValue)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 202,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MinValue)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 203,
      "originalProgramId" : 9,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => (ngram, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, -originalValue._2)\n  } }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 204,
      "originalProgramId" : 9,
      "mutationOperator" : "FTD",
      "mutationOperatorDescription" : "Filter Transformation Deletion",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 205,
      "originalProgramId" : 9,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize).distinct()\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 206,
      "originalProgramId" : 9,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }.distinct()\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 207,
      "originalProgramId" : 9,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }.distinct()\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 208,
      "originalProgramId" : 9,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }.distinct()\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 209,
      "originalProgramId" : 9,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }.distinct()\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 210,
      "originalProgramId" : 9,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => firstParameter }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 211,
      "originalProgramId" : 9,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => secondParameter }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 212,
      "originalProgramId" : 9,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((x: Int, y: Int) => x + y)(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 213,
      "originalProgramId" : 9,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((x: Int, y: Int) => x + y)(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 214,
      "originalProgramId" : 9,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (ngram: List[String]) => filterEmpty(ngram) }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((x: Int, y: Int) => x + y)(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Equivalent"
    },
    {
      "id" : 215,
      "originalProgramId" : 9,
      "mutationOperator" : "NFTP",
      "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
      "mutantCode" : "def countNGrams(input: RDD[String]) = {\n  val sentences = input.flatMap(tokenize)\n  val ngrams = sentences.flatMap { (s: String) => nGrams(s) }\n  val ngramsFiltered = ngrams.filter { (inputParameter: List[String]) => {\n    val originalFunction = ((ngram: List[String]) => filterEmpty(ngram))(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map { (ngram: List[String]) => (ngram, 1) }\n  val ngramsCount = ngramsPairs.reduceByKey { (x: Int, y: Int) => x + y }\n  ngramsCount\n}",
      "originalCode" : "def countNGrams(input: RDD[String]) = {\n    \n    val sentences = input.flatMap(tokenize)\n\n    val ngrams = sentences.flatMap((s: String) => nGrams(s))\n\n    val ngramsFiltered = ngrams.filter((ngram: List[String]) => filterEmpty(ngram))\n\n    val ngramsPairs: RDD[(List[String], Int)] = ngramsFiltered.map((ngram: List[String]) => (ngram, 1))\n\n    val ngramsCount = ngramsPairs.reduceByKey((x: Int, y: Int) => x + y)\n\n    ngramsCount\n  }",
      "status" : "Killed"
    },
    {
      "id" : 216,
      "originalProgramId" : 10,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
      "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 217,
      "originalProgramId" : 10,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map { (inputParameter: String) => {\n    val originalFunction = parseRankings(_)\n    val originalValue = originalFunction(inputParameter)\n    null.asInstanceOf[Ranking]\n  } }\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
      "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 218,
      "originalProgramId" : 10,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  results\n}",
      "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 219,
      "originalProgramId" : 10,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 0)\n  } }\n  results\n}",
      "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 220,
      "originalProgramId" : 10,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 1)\n  } }\n  results\n}",
      "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 221,
      "originalProgramId" : 10,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MaxValue)\n  } }\n  results\n}",
      "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 222,
      "originalProgramId" : 10,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MinValue)\n  } }\n  results\n}",
      "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 223,
      "originalProgramId" : 10,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map { (inputParameter: Ranking) => {\n    val originalFunction = mapRankingToTuple(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, -originalValue._2)\n  } }\n  results\n}",
      "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 224,
      "originalProgramId" : 10,
      "mutationOperator" : "FTD",
      "mutationOperatorDescription" : "Filter Transformation Deletion",
      "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
      "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 225,
      "originalProgramId" : 10,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings).distinct()\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
      "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 226,
      "originalProgramId" : 10,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings).distinct()\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
      "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 227,
      "originalProgramId" : 10,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple).distinct()\n  results\n}",
      "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 228,
      "originalProgramId" : 10,
      "mutationOperator" : "NFTP",
      "mutationOperatorDescription" : "Negation of Filter Transformation Predicate",
      "mutantCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n  val rankings = input.map(parseRankings)\n  val filteredRankings: RDD[Ranking] = rankings.filter { (inputParameter: Ranking) => {\n    val originalFunction = filterRankings(_)\n    val originalValue = originalFunction(inputParameter)\n    !originalValue\n  } }\n  val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n  results\n}",
      "originalCode" : "def scan(input: RDD[String]): RDD[(String, Int)] = {\n    val rankings = input.map(parseRankings)\n    val filteredRankings: RDD[Ranking] = rankings.filter(filterRankings)\n    val results: RDD[(String, Int)] = filteredRankings.map(mapRankingToTuple)\n    results\n  }",
      "status" : "Killed"
    },
    {
      "id" : 229,
      "originalProgramId" : 11,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Killed"
    },
    {
      "id" : 230,
      "originalProgramId" : 11,
      "mutationOperator" : "UTD",
      "mutationOperatorDescription" : "Unary Transformation Deletion",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Killed"
    },
    {
      "id" : 231,
      "originalProgramId" : 11,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (inputParameter: String) => {\n    val originalFunction = ((line: String) => line.split(\" \"))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.headOption\n  } }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Killed"
    },
    {
      "id" : 232,
      "originalProgramId" : 11,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (inputParameter: String) => {\n    val originalFunction = ((line: String) => line.split(\" \"))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.tail\n  } }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Killed"
    },
    {
      "id" : 233,
      "originalProgramId" : 11,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (inputParameter: String) => {\n    val originalFunction = ((line: String) => line.split(\" \"))(_)\n    val originalValue = originalFunction(inputParameter)\n    originalValue.toList.reverse\n  } }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Equivalent"
    },
    {
      "id" : 234,
      "originalProgramId" : 11,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (inputParameter: String) => {\n    val originalFunction = ((line: String) => line.split(\" \"))(_)\n    val originalValue = originalFunction(inputParameter)\n    List[String]()\n  } }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Killed"
    },
    {
      "id" : 235,
      "originalProgramId" : 11,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (\"\", originalValue._2)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Killed"
    },
    {
      "id" : 236,
      "originalProgramId" : 11,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 0)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Killed"
    },
    {
      "id" : 237,
      "originalProgramId" : 11,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, 1)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Equivalent"
    },
    {
      "id" : 238,
      "originalProgramId" : 11,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MaxValue)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Killed"
    },
    {
      "id" : 239,
      "originalProgramId" : 11,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, Int.MinValue)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Killed"
    },
    {
      "id" : 240,
      "originalProgramId" : 11,
      "mutationOperator" : "MTR",
      "mutationOperatorDescription" : "Mapping Transformation Replacement",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (inputParameter: String) => {\n    val originalFunction = ((word: String) => (word, 1))(_)\n    val originalValue = originalFunction(inputParameter)\n    (originalValue._1, -originalValue._2)\n  } }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Killed"
    },
    {
      "id" : 241,
      "originalProgramId" : 11,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }.distinct()\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Killed"
    },
    {
      "id" : 242,
      "originalProgramId" : 11,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }.distinct()\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Killed"
    },
    {
      "id" : 243,
      "originalProgramId" : 11,
      "mutationOperator" : "DTI",
      "mutationOperatorDescription" : "Distinct Transformation Insertion",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (a: Int, b: Int) => a + b }.distinct()\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Equivalent"
    },
    {
      "id" : 244,
      "originalProgramId" : 11,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => firstParameter }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Killed"
    },
    {
      "id" : 245,
      "originalProgramId" : 11,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => secondParameter }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Killed"
    },
    {
      "id" : 246,
      "originalProgramId" : 11,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((a: Int, b: Int) => a + b)(_, _)\n    originalFunction(firstParameter, firstParameter)\n  } }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Killed"
    },
    {
      "id" : 247,
      "originalProgramId" : 11,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((a: Int, b: Int) => a + b)(_, _)\n    originalFunction(secondParameter, secondParameter)\n  } }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Killed"
    },
    {
      "id" : 248,
      "originalProgramId" : 11,
      "mutationOperator" : "ATR",
      "mutationOperatorDescription" : "Aggregation Transformation Replacement",
      "mutantCode" : "def wordCount(input: RDD[String]) = {\n  val words = input.flatMap { (line: String) => line.split(\" \") }\n  val pairs = words.map { (word: String) => (word, 1) }\n  val counts = pairs.reduceByKey { (firstParameter: Int, secondParameter: Int) => {\n    val originalFunction = ((a: Int, b: Int) => a + b)(_, _)\n    originalFunction(secondParameter, firstParameter)\n  } }\n  counts\n}",
      "originalCode" : "def wordCount(input: RDD[String]) = {\n\t\tval words = input.flatMap( (line: String) => line.split(\" \") )\n\t\tval pairs = words.map( (word: String) => (word, 1) )\n\t\tval counts = pairs.reduceByKey( (a: Int, b: Int) => a + b )\n\t\tcounts\n\t}",
      "status" : "Equivalent"
    }
  ],
  "removedMutants" : [
  ],
  "mutationOperatorsMetrics" : {
    "totalMutantsPerOperator" : {
      "FTD" : 7,
      "JTR" : 6,
      "UTR" : 8,
      "MTR" : 101,
      "UTD" : 21,
      "OTD" : 4,
      "BTR" : 0,
      "STR" : 8,
      "BTS" : 0,
      "ATR" : 25,
      "OTI" : 4,
      "DTI" : 52,
      "DTD" : 1,
      "NFTP" : 7,
      "UTS" : 4
    },
    "totalKilledMutantsPerOperator" : {
      "FTD" : 7,
      "JTR" : 3,
      "UTR" : 6,
      "MTR" : 90,
      "UTD" : 21,
      "OTD" : 4,
      "BTR" : 0,
      "STR" : 8,
      "BTS" : 0,
      "ATR" : 20,
      "OTI" : 4,
      "DTI" : 26,
      "DTD" : 1,
      "NFTP" : 7,
      "UTS" : 2
    },
    "totalLivedMutantsPerOperator" : {
      "FTD" : 0,
      "JTR" : 0,
      "UTR" : 0,
      "MTR" : 0,
      "UTD" : 0,
      "OTD" : 0,
      "BTR" : 0,
      "STR" : 0,
      "BTS" : 0,
      "ATR" : 0,
      "OTI" : 0,
      "DTI" : 0,
      "DTD" : 0,
      "NFTP" : 0,
      "UTS" : 0
    },
    "totalEquivalentMutantsPerOperator" : {
      "FTD" : 0,
      "JTR" : 3,
      "UTR" : 2,
      "MTR" : 11,
      "UTD" : 0,
      "OTD" : 0,
      "BTR" : 0,
      "STR" : 0,
      "BTS" : 0,
      "ATR" : 5,
      "OTI" : 0,
      "DTI" : 26,
      "DTD" : 0,
      "NFTP" : 0,
      "UTS" : 2
    },
    "totalErrorMutantsPerOperator" : {
      "FTD" : 0,
      "JTR" : 0,
      "UTR" : 0,
      "MTR" : 0,
      "UTD" : 0,
      "OTD" : 0,
      "BTR" : 0,
      "STR" : 0,
      "BTS" : 0,
      "ATR" : 0,
      "OTI" : 0,
      "DTI" : 0,
      "DTD" : 0,
      "NFTP" : 0,
      "UTS" : 0
    },
    "totalRemovedMutantsPerOperator" : {
      "FTD" : 0,
      "JTR" : 0,
      "UTR" : 0,
      "MTR" : 0,
      "UTD" : 0,
      "OTD" : 0,
      "BTR" : 0,
      "STR" : 0,
      "BTS" : 0,
      "ATR" : 0,
      "OTI" : 0,
      "DTI" : 0,
      "DTD" : 0,
      "NFTP" : 0,
      "UTS" : 0
    },
    "descriptionPerOperator" : {
      "FTD" : "Filter Transformation Deletion",
      "JTR" : "Join Transformation Replacement",
      "UTR" : "Unary Transformation Replacement",
      "MTR" : "Mapping Transformation Replacement",
      "UTD" : "Unary Transformation Deletion",
      "OTD" : "Order Transformation Deletion",
      "BTR" : "Binary Transformation Replacement",
      "STR" : "Set Transformation Replacement",
      "BTS" : "Binary Transformation Swap",
      "ATR" : "Aggregation Transformation Replacement",
      "OTI" : "Order Transformation Inversion",
      "DTI" : "Distinct Transformation Insertion",
      "DTD" : "Distinct Transformation Deletion",
      "NFTP" : "Negation of Filter Transformation Predicate",
      "UTS" : "Unary Transformation Swap"
    }
  },
  "totalProgramSources" : 9,
  "totalPrograms" : 11,
  "totalDatasets" : 67,
  "totalTransformations" : 53,
  "totalMutants" : 248,
  "totalKilledMutants" : 199,
  "totalLivedMutants" : 0,
  "totalEquivalentMutants" : 49,
  "totalErrorMutants" : 0,
  "totalRemovedMutants" : 0,
  "totalMutationScore" : 1.0
}